ğŸ“ pages
  ğŸ“ cases
    ğŸ“„ index.tsx
  ğŸ“ contact
    ğŸ“„ index.tsx
  ğŸ“ index
    ğŸ“„ index.tsx
  ğŸ“ product
    ğŸ“„ index.tsx

===== File: cases\index.tsx =====
import { useState, useCallback, useEffect, useMemo, useRef } from 'react'
import { View } from '@tarojs/components'
import Taro, { useDidShow, useShareAppMessage } from '@tarojs/taro'
import { 
  Empty, 
  InfiniteLoading,
  Popup,
  Toast
} from '@nutui/nutui-react-taro'
import './index.scss'

// Import components
import PageHeader from 'src/components/PageHeader';
import CaseCard from 'src/components/CaseCard';
import CaseDetail from 'src/components/CaseDetail';

// Import API and types
import { 
  CaseData, 
  CaseQueryParams 
} from 'src/services/api/cases/types'
import {
  getCases,
  getCaseDetail,
  handleCasesError,
  CITY_TYPES,
  PAGE_SIZE
} from 'src/services/api/cases/casesApi'

// åˆå§‹çŠ¶æ€å¸¸é‡
const INITIAL_STATE = {
  loading: true,
  cases: [] as CaseData[],
  currentCity: 'all',
  keyword: '',
  selectedCase: null as CaseData | null,
  showDetail: false,
  page: 1,
  hasMore: true,
  showToast: false,
  toastMsg: '',
  toastType: 'fail' as 'success' | 'fail' | 'warn'
};

export default function CasesPage() {
  // çŠ¶æ€ç®¡ç†
  const [loading, setLoading] = useState(INITIAL_STATE.loading);
  const [cases, setCases] = useState<CaseData[]>(INITIAL_STATE.cases);
  const [currentCity, setCurrentCity] = useState(INITIAL_STATE.currentCity);
  const [keyword, setKeyword] = useState(INITIAL_STATE.keyword);
  const [selectedCase, setSelectedCase] = useState<CaseData | null>(INITIAL_STATE.selectedCase);
  const [showDetail, setShowDetail] = useState(INITIAL_STATE.showDetail);
  const [page, setPage] = useState(INITIAL_STATE.page);
  const [hasMore, setHasMore] = useState(INITIAL_STATE.hasMore);
  const [showToast, setShowToast] = useState(INITIAL_STATE.showToast);
  const [toastMsg, setToastMsg] = useState(INITIAL_STATE.toastMsg);
  const [toastType, setToastType] = useState<'success' | 'fail' | 'warn'>(INITIAL_STATE.toastType);

  // ç»„ä»¶æŒ‚è½½çŠ¶æ€è¿½è¸ª
  const isMounted = useRef(true);
  const loadingRef = useRef(false);
  
  useEffect(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);

  // åˆ†äº«åŠŸèƒ½
  useShareAppMessage(() => ({
    title: 'éƒ‘å¼ä¿®ç¼®é˜²æ°´å·¥ç¨‹æ¡ˆä¾‹',
    path: '/pages/cases/index',
    imageUrl: cases.length > 0 ? cases[0].images[0] : undefined,
  }));

  // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
  const showToastMessage = useCallback((message: string, type: 'success' | 'fail' | 'warn' = 'fail') => {
    if (!isMounted.current) return;
    setToastMsg(message);
    setToastType(type);
    setShowToast(true);
  }, []);

  // åŠ è½½æ¡ˆä¾‹æ•°æ®
  const loadCases = useCallback(
    async (isRefresh = false) => {
      // é˜²æ­¢é‡å¤åŠ è½½
      if (loadingRef.current) return;
      
      try {
        loadingRef.current = true;
        const currentPage = isRefresh ? 1 : page;
        
        if (isRefresh) {
          setLoading(true);
        }

        const res = await getCases({
          city: currentCity,
          keyword,
          page: currentPage,
          pageSize: PAGE_SIZE,
        });

        if (!isMounted.current) return;

        if (res.success) {
          const responseData = res.data || [];
          
          if (isRefresh) {
            setCases(responseData);
            setPage(1);
            setHasMore(res.hasMore || false);
          } else {
            setCases(prev => [...prev, ...responseData]);
            setPage(prev => prev + 1);
            setHasMore(res.hasMore || false);
          }
        } else {
          showToastMessage(res.error || 'è·å–æ¡ˆä¾‹åˆ—è¡¨å¤±è´¥');
        }
      } catch (err) {
        if (!isMounted.current) return;
        showToastMessage(handleCasesError(err));
      } finally {
        if (!isMounted.current) return;
        setLoading(false);
        loadingRef.current = false;
      }
    },
    [currentCity, keyword, page, showToastMessage]
  );

  // åŸå¸‚æˆ–å…³é”®è¯å˜åŒ–æ—¶é‡æ–°åŠ è½½
  useEffect(() => {
    loadCases(true);
  }, [currentCity, keyword]);

  // é¡µé¢æ˜¾ç¤ºæ—¶æ£€æŸ¥æ•°æ®
  useDidShow(() => {
    if (cases.length === 0 && !loading) {
      loadCases(true);
    }
  });

  // å¤„ç†æœç´¢è¾“å…¥å˜åŒ–
  const handleSearch = useCallback((value: string) => {
    setKeyword(value);
    setPage(1);
  }, []);

  // å¤„ç†åŸå¸‚å˜åŒ–
  const handleCityChange = useCallback((value: string) => {
    setCurrentCity(value);
    setPage(1);
  }, []);

  // å¤„ç†åŠ è½½æ›´å¤š
  const handleLoadMore = useCallback(() => {
    if (hasMore && !loading && !loadingRef.current) {
      return loadCases(false);
    }
    return Promise.resolve();
  }, [hasMore, loading, loadCases]);

  // å¤„ç†æ¡ˆä¾‹ç‚¹å‡»
  const handleCaseClick = useCallback(async (id: number) => {
    try {
      // å…ˆæ£€æŸ¥ç¼“å­˜
      const cachedCase = cases.find(c => c.id === id);
      if (cachedCase) {
        setSelectedCase(cachedCase);
        setShowDetail(true);
        return;
      }
      
      setLoading(true);
      const res = await getCaseDetail(id);
      
      if (!isMounted.current) return;
      
      if (res.success && res.data) {
        setSelectedCase(res.data);
        setShowDetail(true);
      } else {
        showToastMessage(res.error || 'è·å–æ¡ˆä¾‹è¯¦æƒ…å¤±è´¥');
      }
    } catch (err) {
      if (!isMounted.current) return;
      showToastMessage(handleCasesError(err));
    } finally {
      if (!isMounted.current) return;
      setLoading(false);
    }
  }, [cases, showToastMessage]);

  // å¤„ç†é¢„çº¦æœåŠ¡
  const handleBook = useCallback(() => {
    setShowDetail(false);
    // ç›´æ¥è·³è½¬åˆ°è”ç³»é¡µé¢
    Taro.switchTab({
      url: '/pages/contact/index',
    });
  }, []);

  // å¤„ç†è¯¦æƒ…å…³é—­
  const handleCloseDetail = useCallback(() => {
    setShowDetail(false);
    // å»¶è¿Ÿæ¸…ç†æ•°æ®ï¼Œç­‰å¾…åŠ¨ç”»ç»“æŸ
    setTimeout(() => {
      if (isMounted.current) {
        setSelectedCase(null);
      }
    }, 300);
  }, []);

  // éª¨æ¶å±UI
  const renderSkeletons = useMemo(() => {
    return (
      <View className="cases-page-skeletons">
        {[1, 2, 3].map((i) => (
          <View key={i} className="cases-page-skeleton">
            <View className="cases-page-skeleton-image"></View>
            <View className="cases-page-skeleton-content">
              <View className="cases-page-skeleton-title"></View>
              <View className="cases-page-skeleton-desc"></View>
              <View className="cases-page-skeleton-date"></View>
            </View>
          </View>
        ))}
      </View>
    );
  }, []);

  return (
    <View className="cases-page">
      {/* Headerå®¹å™¨ */}
      <View className="cases-page-header">
        <PageHeader
          keyword={keyword}
          onSearch={handleSearch}
          searchPlaceholder="æœç´¢åŸå¸‚æ¡ˆä¾‹"
          currentType={currentCity}
          onTypeChange={handleCityChange}
          tabs={CITY_TYPES}
        />
      </View>

      {/* å†…å®¹åŒºåŸŸ */}
      <View className="cases-page-content">
        {/* åŠ è½½çŠ¶æ€ */}
        {loading && cases.length === 0 ? (
          renderSkeletons
        ) : cases.length > 0 ? (
          <View className="cases-page-list">
            {cases.map((item, index) => (
              <View key={item.id} className={`cases-page-item cases-page-item-${Math.min(index + 1, 10)}`}>
                <CaseCard
                  id={item.id}
                  title={item.title}
                  description={item.description}
                  date={item.date}
                  image={item.images[0]}
                  onClick={() => handleCaseClick(item.id)}
                />
              </View>
            ))}
          </View>
        ) : (
          <View className="cases-page-empty">
            <Empty description="æš‚æ— ç›¸å…³æ¡ˆä¾‹" image="empty" />
          </View>
        )}

        {/* æ— é™åŠ è½½ */}
        {cases.length > 0 && (
          <InfiniteLoading
            hasMore={hasMore}
            threshold={200}
            loadingText="åŠ è½½ä¸­..."
            loadMoreText="å·²ç»åˆ°åº•å•¦"
            onLoadMore={handleLoadMore}
          />
        )}
      </View>

      {/* æ¡ˆä¾‹è¯¦æƒ…å¼¹çª— */}
      <Popup
        visible={showDetail}
        position="bottom"
        round
        style={{ height: '90%' }}
        onClose={handleCloseDetail}
        closeable={false}
      >
        {selectedCase && (
          <CaseDetail 
            caseData={selectedCase}
            visible={showDetail}
            onClose={handleCloseDetail}
            onContactClick={handleBook}
          />
        )}
      </Popup>

      {/* Toastç»„ä»¶ */}
      <Toast
        msg={toastMsg}
        visible={showToast}
        type={toastType}
        onClose={() => setShowToast(false)}
        duration={2000}
        position="center"
        closeOnOverlayClick
      />
    </View>
  );
}
===== End of File: cases\index.tsx =====


===== File: contact\index.tsx =====
import { useState, useEffect } from 'react'
import { View, Text } from '@tarojs/components'
import Taro from '@tarojs/taro'
import { Loading, Toast } from '@nutui/nutui-react-taro'
import BookingForm from '../../components/BookingForm'
import ContactInfoCard from '../../components/ContactInfoCard'
import './index.scss'

import { 
  ServiceType, 
  ContactData, 
  BookingFormData 
} from 'src/services/api/contact/types'
import { 
  getServiceTypes, 
  getContactData, 
  submitBooking, 
  handleContactError 
} from 'src/services/api/contact/contactApi'

export default function ContactPage() {
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [showToast, setShowToast] = useState(false);
  const [toastInfo, setToastInfo] = useState({ content: '', icon: 'success' });
  
  const [serviceTypes, setServiceTypes] = useState<ServiceType[]>([]);
  const [contactData, setContactData] = useState<ContactData | null>(null);
  
  const [formData, setFormData] = useState<Partial<BookingFormData>>({
    name: '',
    phone: '',
    serviceType: '',
    serviceTypeName: '',
    region: [],
    address: '',
    remark: ''
  });
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        
        const [serviceTypesRes, contactDataRes] = await Promise.all([
          getServiceTypes(),
          getContactData()
        ]);
        
        if (serviceTypesRes.success && serviceTypesRes.data) {
          setServiceTypes(serviceTypesRes.data);
        } else {
          showMessage(serviceTypesRes.error || 'è·å–æœåŠ¡ç±»å‹å¤±è´¥', 'fail');
        }
        
        if (contactDataRes.success && contactDataRes.data) {
          setContactData(contactDataRes.data);
        } else {
          showMessage(contactDataRes.error || 'è·å–è”ç³»ä¿¡æ¯å¤±è´¥', 'fail');
        }
      } catch (error) {
        console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
        showMessage('åŠ è½½æ•°æ®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'fail');
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, []);
  
  const showMessage = (content: string, icon: 'success' | 'fail' | 'loading' = 'success') => {
    setToastInfo({ content, icon });
    setShowToast(true);
  };
  
  const handleFormSubmit = async (data: BookingFormData) => {
    setSubmitting(true);
    
    try {
      const res = await submitBooking(data);
      
      if (res.success) {
        Taro.vibrateShort({ type: 'medium' });
        showMessage('é¢„çº¦æˆåŠŸï¼Œæˆ‘ä»¬å°†å°½å¿«ä¸æ‚¨è”ç³»ï¼');
        
        setFormData({
          name: '',
          phone: '',
          serviceType: '',
          serviceTypeName: '',
          region: [],
          address: '',
          remark: ''
        });
      } else {
        showMessage(res.error || 'æäº¤å¤±è´¥ï¼Œè¯·é‡è¯•', 'fail');
      }
    } catch (error) {
      showMessage(handleContactError(error), 'fail');
    } finally {
      setSubmitting(false);
    }
  };
  
  const handleServiceTypeSelect = (typeValue: string) => {
    const selectedType = serviceTypes.find(type => type.value === typeValue);
    setFormData(prev => ({
      ...prev,
      serviceType: typeValue,
      serviceTypeName: selectedType?.text || ''
    }));
  };
  
  const handlePhoneCall = (phone: string) => {
    Taro.makePhoneCall({
      phoneNumber: phone,
      fail: (err) => {
        if (err.errMsg && !err.errMsg.includes('cancel')) {
          showMessage('æ‹¨æ‰“ç”µè¯å¤±è´¥ï¼Œè¯·é‡è¯•', 'fail');
        }
      }
    });
  };
  
  const handleCopyWechat = () => {
    if (!contactData) return;
    
    Taro.setClipboardData({
      data: contactData.wechat,
      success: () => {
      },
      fail: () => {
        showMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•', 'fail');
      }
    });
  };
  
  if (loading || !contactData) {
    return (
      <View className="loading-container">
        <Loading type="spinner" color="#2563EB" />
        <Text className="loading-text">åŠ è½½ä¸­...</Text>
      </View>
    );
  }
  
  return (
    <View className="contact-page">
      <View className="contact-container">
        <View className="contact-card booking-card">
          <View className="card-header">
            <Text className="card-title">é¢„çº¦æœåŠ¡</Text>
            <Text className="card-subtitle">å¡«å†™ä¿¡æ¯å…è´¹ä¸Šé—¨å‹˜æµ‹</Text>
          </View>
          <View className="card-content">
            <BookingForm 
              serviceTypes={serviceTypes}
              loading={submitting}
              initialValues={formData}
              onSubmit={handleFormSubmit}
              onServiceTypeSelect={handleServiceTypeSelect}
            />
          </View>
        </View>
        
        <View className="contact-card about-card">
          <View className="card-header">
            <Text className="card-title">è”ç³»æˆ‘ä»¬</Text>
            <Text className="card-subtitle">{contactData.address}</Text>
          </View>
          <View className="card-content">
            <ContactInfoCard 
              data={contactData}
              onPhoneCall={handlePhoneCall}
              onCopyWechat={handleCopyWechat}
            />
          </View>
        </View>
      </View>
      
      <Toast
        visible={showToast}
        content={toastInfo.content}
        icon={toastInfo.icon as any}
        onClose={() => setShowToast(false)}
        duration={2000}
      />
    </View>
  );
}
===== End of File: contact\index.tsx =====


===== File: index\index.tsx =====
// pages/index/index.tsx
import { useEffect, useState, useCallback } from 'react'
import { View, Text } from '@tarojs/components'
import { Toast, Loading } from '@nutui/nutui-react-taro'
import Taro from '@tarojs/taro'
import './index.scss'

// å¯¼å…¥ç»„ä»¶
import BannerCarousel from 'src/components/BannerCarousel'
import QuickContact from 'src/components/QuickContact'
import ServiceSection from 'src/components/ServiceSection'
import ShowcaseSection from 'src/components/ShowcaseSection'

// ç›´æ¥å¯¼å…¥APIå’Œç±»å‹
import { IndexData } from 'src/services/api/index/types'
import { getIndexData, handleIndexError } from 'src/services/api/index/indexApi'

export default function IndexPage() {
  // çŠ¶æ€ç®¡ç†
  const [loading, setLoading] = useState(true)
  const [indexData, setIndexData] = useState<IndexData | null>(null)
  const [showToast, setShowToast] = useState(false)
  const [toastMsg, setToastMsg] = useState('')
  const [toastType, setToastType] = useState<'success' | 'fail' | 'warn'>('success')
  
  // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
  const showToastMessage = useCallback((message: string, type: 'success' | 'fail' | 'warn' = 'success') => {
    if (showToast) {
      setShowToast(false)
      setTimeout(() => {
        setToastMsg(message)
        setToastType(type)
        setShowToast(true)
      }, 100)
    } else {
      setToastMsg(message)
      setToastType(type)
      setShowToast(true)
    }
  }, [showToast])
  
  // è·å–æ•°æ®
  const fetchData = useCallback(async () => {
    setLoading(true)
    
    try {
      // è·å–æ‰€æœ‰é¦–é¡µæ•°æ®
      const result = await getIndexData()
      
      if (result.success && result.data) {
        setIndexData(result.data)
      } else {
        showToastMessage(result.error || 'è·å–é¦–é¡µæ•°æ®å¤±è´¥', 'fail')
      }
    } catch (error) {
      console.error('åŠ è½½æ•°æ®å¤±è´¥:', error)
      showToastMessage(handleIndexError(error), 'fail')
    } finally {
      setLoading(false)
    }
  }, [showToastMessage])
  
  // ä¸‹æ‹‰åˆ·æ–°å¤„ç†
  const handlePullDownRefresh = useCallback(async () => {
    try {
      // åˆ·æ–°é¦–é¡µæ•°æ®
      const result = await getIndexData()
      
      if (result.success && result.data) {
        setIndexData(result.data)
        showToastMessage('åˆ·æ–°æˆåŠŸ', 'success')
      } else {
        showToastMessage(result.error || 'åˆ·æ–°æ•°æ®å¤±è´¥', 'fail')
      }
    } catch (error) {
      showToastMessage(handleIndexError(error), 'fail')
    } finally {
      Taro.stopPullDownRefresh()
    }
  }, [showToastMessage])
  
  // ç»„ä»¶æŒ‚è½½æ—¶è·å–æ•°æ®
  useEffect(() => {
    fetchData()
  }, [fetchData])
  
  // ä¸‹æ‹‰åˆ·æ–°äº‹ä»¶ç›‘å¬
  useEffect(() => {
    Taro.eventCenter.on('pullDownRefresh', handlePullDownRefresh)
    
    return () => {
      Taro.eventCenter.off('pullDownRefresh', handlePullDownRefresh)
    }
  }, [handlePullDownRefresh])
  
  // åŠ è½½çŠ¶æ€
  if (loading || !indexData) {
    return (
      <View className='loading-container'>
        <Loading type='spinner' />
        <Text className='loading-text'>åŠ è½½ä¸­...</Text>
      </View>
    )
  }
  
  return (
    <View className='page'>
      {/* BanneråŒºåŸŸ */}
      <BannerCarousel banners={indexData.banners} />
      
      {/* å¿«é€Ÿè”ç³» */}
      <QuickContact 
        contactInfo={indexData.contactInfo}
        onShowToast={showToastMessage}
      />
      
      {/* æœåŠ¡é¡¹ç›® */}
      <ServiceSection 
        services={indexData.services}
        title="æˆ‘ä»¬çš„æœåŠ¡"
      />
      
      {/* ç²¾é€‰æ¡ˆä¾‹ */}
      <ShowcaseSection 
        showcases={indexData.showcases}
        onShowToast={showToastMessage}
      />
      
      {/* Toastç»„ä»¶ */}
      <Toast
        msg={toastMsg}
        visible={showToast}
        type={toastType}
        onClose={() => setShowToast(false)}
        duration={2000}
        position='center'
        closeOnOverlayClick
      />
    </View>
  )
}
===== End of File: index\index.tsx =====


===== File: product\index.tsx =====
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { View } from '@tarojs/components';
import Taro, { useDidShow, useShareAppMessage } from '@tarojs/taro';
import { 
  Empty, 
  Toast,
  Popup,
  InfiniteLoading
} from '@nutui/nutui-react-taro';
import ProductCard from 'src/components/ProductCard';
import ProductDetail from 'src/components/ProductDetail';
import { 
  getCoatingList, 
  getCoatingDetail, 
  WaterproofCoating 
} from 'src/services/api/product/coatingApi';
import './index.scss';

// å¸¸é‡å®šä¹‰
const SKELETON_COUNT = 4;
const PAGE_SIZE = 10;
const POPUP_HEIGHT = '92%';
const TOAST_DURATION = 2000;

// çŠ¶æ€ç±»å‹å®šä¹‰
interface PageState {
  loading: boolean;
  loadingMore: boolean;
  products: WaterproofCoating[];
  selectedProduct: WaterproofCoating | null;
  showDetail: boolean;
  currentPage: number;
  hasMore: boolean;
}

interface ToastState {
  show: boolean;
  msg: string;
  type: 'success' | 'fail' | 'warn';
}

// åˆå§‹çŠ¶æ€
const initialState: PageState = {
  loading: true,
  loadingMore: false,
  products: [],
  selectedProduct: null,
  showDetail: false,
  currentPage: 1,
  hasMore: true
};

const initialToast: ToastState = {
  show: false,
  msg: '',
  type: 'fail'
};

export default function ProductPage() {
  const [state, setState] = useState<PageState>(initialState);
  const [toast, setToast] = useState<ToastState>(initialToast);
  const isMounted = useRef(true);
  
  // ç”Ÿå‘½å‘¨æœŸç®¡ç†
  useEffect(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);
  
  // åˆ†äº«é…ç½®
  useShareAppMessage(() => ({
    title: 'ä¸“ä¸šé˜²æ°´äº§å“',
    path: '/pages/product/index',
    imageUrl: state.products[0]?.images[0]
  }));

  // å·¥å…·å‡½æ•°
  const showToastMessage = useCallback((message: string, type: ToastState['type'] = 'fail') => {
    if (!isMounted.current) return;
    setToast({ show: true, msg: message, type });
  }, []);

  const updateState = useCallback((updates: Partial<PageState>) => {
    if (!isMounted.current) return;
    setState(prev => ({ ...prev, ...updates }));
  }, []);

  // æ•°æ®è·å–
  const fetchProducts = useCallback(async (isRefresh = false) => {
    try {
      const page = isRefresh ? 1 : state.currentPage;
      
      updateState({
        [isRefresh ? 'loading' : 'loadingMore']: true
      });
      
      const response = await getCoatingList({ page, pageSize: PAGE_SIZE });

      if (!isMounted.current) return;
      
      if (response.success) {
        const productData = response.data || [];
        
        updateState({
          products: isRefresh ? productData : [...state.products, ...productData],
          currentPage: isRefresh ? 2 : state.currentPage + 1,
          hasMore: response.hasMore || false,
          loading: false,
          loadingMore: false
        });
      } else {
        throw new Error(response.error || 'è·å–äº§å“æ•°æ®å¤±è´¥');
      }
    } catch (error) {
      if (!isMounted.current) return;
      console.error('è·å–äº§å“æ•°æ®é”™è¯¯', error);
      showToastMessage(error instanceof Error ? error.message : 'è·å–äº§å“æ•°æ®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
      updateState({ loading: false, loadingMore: false });
    }
  }, [state.currentPage, state.products, showToastMessage, updateState]);

  // åˆå§‹åŒ–åŠ è½½
  useEffect(() => {
    fetchProducts(true);
  }, []);

  // é¡µé¢æ˜¾ç¤ºæ—¶æ£€æŸ¥
  useDidShow(() => {
    if (state.products.length === 0 && !state.loading) {
      fetchProducts(true);
    }
  });

  // ä¸‹æ‹‰åˆ·æ–°
  useEffect(() => {
    const handlePullDownRefresh = async () => {
      await fetchProducts(true);
      Taro.stopPullDownRefresh();
    };
    
    Taro.eventCenter.on('pullDownRefresh', handlePullDownRefresh);
    return () => {
      Taro.eventCenter.off('pullDownRefresh', handlePullDownRefresh);
    };
  }, [fetchProducts]);

  // äº‹ä»¶å¤„ç†
  const handleProductClick = useCallback(async (id: number) => {
    try {
      updateState({ loading: true });
      const response = await getCoatingDetail(id);
      
      if (!isMounted.current) return;
      
      if (response.success && response.data) {
        updateState({
          selectedProduct: response.data,
          showDetail: true,
          loading: false
        });
      } else {
        throw new Error(response.error || 'è·å–äº§å“è¯¦æƒ…å¤±è´¥');
      }
    } catch (error) {
      if (!isMounted.current) return;
      console.error('è·å–äº§å“è¯¦æƒ…é”™è¯¯', error);
      showToastMessage(error instanceof Error ? error.message : 'è·å–äº§å“è¯¦æƒ…å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
      updateState({ loading: false });
    }
  }, [showToastMessage, updateState]);

  const handleCloseDetail = useCallback(() => {
    updateState({ showDetail: false });
    setTimeout(() => {
      updateState({ selectedProduct: null });
    }, 300);
  }, [updateState]);

  const handleContactClick = useCallback(() => {
    handleCloseDetail();
    Taro.switchTab({ url: '/pages/contact/index' });
  }, [handleCloseDetail]);

  const handleLoadMore = useCallback(() => {
    if (state.hasMore && !state.loading && !state.loadingMore) {
      return fetchProducts(false);
    }
    return Promise.resolve();
  }, [state.hasMore, state.loading, state.loadingMore, fetchProducts]);

  // æ¸²æŸ“å‡½æ•°
  const renderSkeletons = useMemo(() => (
    <View className="product-grid">
      {Array.from({ length: SKELETON_COUNT }, (_, i) => (
        <View key={i} className="product-skeleton">
          <View className="product-skeleton__image" />
          <View className="product-skeleton__content">
            <View className="product-skeleton__title" />
            <View className="product-skeleton__title" />
            <View className="product-skeleton__price" />
          </View>
        </View>
      ))}
    </View>
  ), []);

  const renderProducts = useMemo(() => (
    <>
      <View className="product-grid">
        {state.products.map((product) => (
          <View key={product.id} className="product-grid__item">
            <ProductCard
              image={product.images[0]}
              title={product.title}
              specifications={product.specifications}
              onClick={() => handleProductClick(product.id)}
            />
          </View>
        ))}
      </View>
      
      <InfiniteLoading
        hasMore={state.hasMore}
        threshold={100}
        loadingText="åŠ è½½ä¸­..."
        loadMoreText="å·²ç»åˆ°åº•å•¦"
        onLoadMore={handleLoadMore}
      />
    </>
  ), [state.products, state.hasMore, handleProductClick, handleLoadMore]);

  const renderEmpty = useMemo(() => (
    <View className="product-page__empty">
      <Empty description="æš‚æ— ç›¸å…³äº§å“" image="empty" />
    </View>
  ), []);

  return (
    <View className="product-page">
      <View className="product-page__container">
        {state.loading && state.products.length === 0 
          ? renderSkeletons 
          : state.products.length > 0 
            ? renderProducts 
            : renderEmpty
        }
      </View>

      <Popup
        visible={state.showDetail}
        position="bottom"
        round
        style={{ height: POPUP_HEIGHT }}
        onClose={handleCloseDetail}
        closeable={false}
      >
        {state.selectedProduct && (
          <ProductDetail 
            product={state.selectedProduct}
            visible={state.showDetail}
            onClose={handleCloseDetail}
            onContactClick={handleContactClick}
          />
        )}
      </Popup>

      <Toast
        msg={toast.msg}
        visible={toast.show}
        type={toast.type}
        onClose={() => setToast(prev => ({ ...prev, show: false }))}
        duration={TOAST_DURATION}
        position="center"
      />
    </View>
  );
}
===== End of File: product\index.tsx =====

