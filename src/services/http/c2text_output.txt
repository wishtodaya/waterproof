ğŸ“ http
  ğŸ“„ cache.ts
  ğŸ“„ config.ts
  ğŸ“„ errorHandler.ts
  ğŸ“„ index.ts
  ğŸ“„ interceptor.ts
  ğŸ“„ request.ts
  ğŸ“„ types.ts

===== File: cache.ts =====
import Taro from '@tarojs/taro';
import type { CacheData } from './types';

// ç¼“å­˜é”®å‰ç¼€
const CACHE_PREFIX = 'http_cache_';

/**
 * ç”Ÿæˆç¼“å­˜é”®
 */
export function generateCacheKey(url: string, data?: any): string {
  return `${CACHE_PREFIX}${url}_${JSON.stringify(data || {})}`;
}

/**
 * è·å–ç¼“å­˜æ•°æ®
 */
export function getCacheData<T>(key: string): CacheData<T> | null {
  try {
    const cacheData = Taro.getStorageSync(key);
    return cacheData ? JSON.parse(cacheData) : null;
  } catch (error) {
    console.error('è·å–ç¼“å­˜æ•°æ®å¤±è´¥', error);
    return null;
  }
}

/**
 * è®¾ç½®ç¼“å­˜æ•°æ®
 */
export function setCacheData<T>(key: string, data: T): void {
    try {
      const cacheData: CacheData<T> = {
        data,
        timestamp: Date.now()
      };
      
      Taro.setStorageSync(key, JSON.stringify(cacheData));
    } catch (error) {
      console.error('è®¾ç½®ç¼“å­˜æ•°æ®å¤±è´¥', error);
    }
  }

/**
 * æ¸…é™¤ç¼“å­˜æ•°æ®
 */
export function clearCacheData(key: string): void {
  try {
    Taro.removeStorageSync(key);
  } catch (error) {
    console.error('æ¸…é™¤ç¼“å­˜æ•°æ®å¤±è´¥', error);
  }
}

/**
 * æ¸…é™¤æ‰€æœ‰HTTPç¼“å­˜
 */
export function clearAllCache(): void {
  try {
    const storageInfo = Taro.getStorageInfoSync();
    const keys = storageInfo.keys || [];
    
    keys.forEach(key => {
      if (key.startsWith(CACHE_PREFIX)) {
        Taro.removeStorageSync(key);
      }
    });
  } catch (error) {
    console.error('æ¸…é™¤æ‰€æœ‰ç¼“å­˜å¤±è´¥', error);
  }
}

/**
 * æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ
 */
export function isCacheValid<T>(cache: CacheData<T>, cacheTime: number): boolean {
  if (!cache || !cache.timestamp) return false;
  
  return Date.now() - cache.timestamp < cacheTime;
}
===== End of File: cache.ts =====


===== File: config.ts =====
import type { HttpRequestConfig } from './types';

// APIåŸºç¡€URL
export const API_BASE_URL = {
  // å¼€å‘ç¯å¢ƒ
  development: 'http://localhost:8080/jeecg-boot',
  // ç”Ÿäº§ç¯å¢ƒ
  production: 'https://your-api-domain.com/jeecg-boot'
};

// ç¯å¢ƒåˆ¤æ–­
export const ENV = process.env.NODE_ENV || 'development';

// HTTPçŠ¶æ€ç 
export const HTTP_STATUS = {
  SUCCESS: 200,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  SERVER_ERROR: 500
};

// ä¸šåŠ¡çŠ¶æ€ç 
export const BUSINESS_CODE = {
  SUCCESS: 200,           // jeecg-bootæˆåŠŸçŠ¶æ€ç 
  TOKEN_EXPIRED: 401,     // tokenè¿‡æœŸ
  PARAM_ERROR: 400,       // å‚æ•°é”™è¯¯
  SERVER_ERROR: 500       // æœåŠ¡å™¨é”™è¯¯
};

// é»˜è®¤è¯·æ±‚é…ç½®
export const DEFAULT_CONFIG: HttpRequestConfig = {
  baseURL: API_BASE_URL[ENV],
  showLoading: true,
  loadingText: 'åŠ è½½ä¸­',
  showErrorToast: true,
  headers: {
    'Content-Type': 'application/json'
  },
  timeout: 10000,       // 10ç§’
  useCache: false,
  cacheTime: 5 * 60 * 1000,  // 5åˆ†é’Ÿ
  retry: 0,
  retryDelay: 1000,
  withToken: true
};
===== End of File: config.ts =====


===== File: errorHandler.ts =====
import Taro from '@tarojs/taro';
import { HTTP_STATUS, BUSINESS_CODE } from './config';
import type { RequestError, HttpRequestOptions } from './types';

/**
 * å¤„ç†HTTPçŠ¶æ€é”™è¯¯
 */
export function handleHttpError(statusCode: number): RequestError {
  let message = 'æœªçŸ¥é”™è¯¯';
  
  switch (statusCode) {
    case HTTP_STATUS.BAD_REQUEST:
      message = 'è¯·æ±‚å‚æ•°é”™è¯¯';
      break;
    case HTTP_STATUS.UNAUTHORIZED:
      message = 'æœªæˆæƒï¼Œè¯·ç™»å½•';
      break;
    case HTTP_STATUS.FORBIDDEN:
      message = 'æ²¡æœ‰æƒé™è®¿é—®';
      break;
    case HTTP_STATUS.NOT_FOUND:
      message = 'è¯·æ±‚èµ„æºä¸å­˜åœ¨';
      break;
    case HTTP_STATUS.SERVER_ERROR:
      message = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯';
      break;
    default:
      message = `HTTPé”™è¯¯ (${statusCode})`;
  }
  
  return {
    code: statusCode,
    message
  };
}

/**
 * å¤„ç†jeecg-bootä¸šåŠ¡çŠ¶æ€é”™è¯¯
 */
export function handleBusinessError<T>(response: { success?: boolean; code?: number; message?: string; data?: T }): RequestError {
  let message = response.message || 'æœªçŸ¥é”™è¯¯';
  let code = response.code || -1;
  
  // jeecg-bootè¿”å›æ ¼å¼å¤„ç†
  if (response.success === false) {
    return {
      code: code,
      message: message,
      data: response.data
    };
  }
  
  // ä¼ ç»Ÿcodeå¤„ç†
  switch (code) {
    case BUSINESS_CODE.TOKEN_EXPIRED:
      message = 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•';
      break;
    case BUSINESS_CODE.PARAM_ERROR:
      message = 'å‚æ•°é”™è¯¯';
      break;
    case BUSINESS_CODE.SERVER_ERROR:
      message = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯';
      break;
  }
  
  return {
    code: code,
    message,
    data: response.data
  };
}

/**
 * å¤„ç†ç½‘ç»œé”™è¯¯
 */
export function handleNetworkError(error: any): RequestError {
  let message = 'ç½‘ç»œå¼‚å¸¸';
  
  if (error?.errMsg) {
    if (error.errMsg.includes('timeout')) {
      message = 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ';
    } else if (error.errMsg.includes('fail')) {
      message = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®';
    }
  }
  
  return {
    code: -1,
    message
  };
}

/**
 * ç»¼åˆé”™è¯¯å¤„ç†
 */
export function handleRequestError(error: any, options: HttpRequestOptions): RequestError {
  // å·²æ ¼å¼åŒ–çš„é”™è¯¯
  if (error && typeof error === 'object' && 'code' in error && 'message' in error) {
    if (options.showErrorToast) {
      Taro.showToast({
        title: error.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return error as RequestError;
  }
  
  // HTTPé”™è¯¯
  if (error && typeof error === 'object' && 'statusCode' in error) {
    const httpError = handleHttpError(error.statusCode);
    
    if (options.showErrorToast) {
      Taro.showToast({
        title: httpError.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return httpError;
  }
  
  // ç½‘ç»œé”™è¯¯
  if (error && typeof error === 'object' && 'errMsg' in error) {
    const networkError = handleNetworkError(error);
    
    if (options.showErrorToast) {
      Taro.showToast({
        title: networkError.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return networkError;
  }
  
  // å…¶ä»–é”™è¯¯
  const unknownError: RequestError = {
    code: -1,
    message: typeof error === 'string' ? error : 'æœªçŸ¥é”™è¯¯'
  };
  
  if (options.showErrorToast) {
    Taro.showToast({
      title: unknownError.message,
      icon: 'none',
      duration: 2000
    });
  }
  
  return unknownError;
}
===== End of File: errorHandler.ts =====


===== File: index.ts =====
import { request } from './request';
import type { HttpRequestOptions } from './types';
import { addRequestInterceptor, addResponseInterceptor, addErrorInterceptor } from './interceptor';
import { clearAllCache, clearCacheData } from './cache';

/**
 * HTTPå®¢æˆ·ç«¯
 */
const http = {
  /**
   * å‘é€GETè¯·æ±‚
   */
  get: <T = any>(url: string, data?: any, options?: Partial<HttpRequestOptions>) => 
    request<T>({ url, method: 'GET', data, ...options }),
  
  /**
   * å‘é€POSTè¯·æ±‚
   */  
  post: <T = any>(url: string, data?: any, options?: Partial<HttpRequestOptions>) => 
    request<T>({ url, method: 'POST', data, ...options }),
  
  /**
   * å‘é€PUTè¯·æ±‚
   */
  put: <T = any>(url: string, data?: any, options?: Partial<HttpRequestOptions>) => 
    request<T>({ url, method: 'PUT', data, ...options }),
  
  /**
   * å‘é€DELETEè¯·æ±‚
   */
  delete: <T = any>(url: string, data?: any, options?: Partial<HttpRequestOptions>) => 
    request<T>({ url, method: 'DELETE', data, ...options }),
  
  /**
   * åŸå§‹è¯·æ±‚æ–¹æ³•
   */
  request,
  
  /**
   * æ¸…é™¤æŒ‡å®šç¼“å­˜
   */
  clearCache: clearCacheData,
  
  /**
   * æ¸…é™¤æ‰€æœ‰ç¼“å­˜
   */
  clearAllCache,
  
  /**
   * æ·»åŠ è¯·æ±‚æ‹¦æˆªå™¨
   */
  addRequestInterceptor,
  
  /**
   * æ·»åŠ å“åº”æ‹¦æˆªå™¨
   */
  addResponseInterceptor,
  
  /**
   * æ·»åŠ é”™è¯¯æ‹¦æˆªå™¨
   */
  addErrorInterceptor
};

export default http;

// å¯¼å‡ºç±»å‹
export * from './types';
export { DEFAULT_CONFIG } from './config';
===== End of File: index.ts =====


===== File: interceptor.ts =====
import Taro from '@tarojs/taro';
import type { RequestInterceptor, ResponseInterceptor, ErrorInterceptor, HttpRequestOptions, ResponseData } from './types';
import { BUSINESS_CODE } from './config';

// è¯·æ±‚æ‹¦æˆªå™¨æ•°ç»„
const requestInterceptors: RequestInterceptor[] = [];

// å“åº”æ‹¦æˆªå™¨æ•°ç»„
const responseInterceptors: ResponseInterceptor[] = [];

// é”™è¯¯æ‹¦æˆªå™¨æ•°ç»„
const errorInterceptors: ErrorInterceptor[] = [];

/**
 * æ·»åŠ è¯·æ±‚æ‹¦æˆªå™¨
 */
export function addRequestInterceptor(interceptor: RequestInterceptor): void {
  requestInterceptors.push(interceptor);
}

/**
 * æ·»åŠ å“åº”æ‹¦æˆªå™¨
 */
export function addResponseInterceptor(interceptor: ResponseInterceptor): void {
  responseInterceptors.push(interceptor);
}

/**
 * æ·»åŠ é”™è¯¯æ‹¦æˆªå™¨
 */
export function addErrorInterceptor(interceptor: ErrorInterceptor): void {
  errorInterceptors.push(interceptor);
}

/**
 * åº”ç”¨è¯·æ±‚æ‹¦æˆªå™¨
 */
export async function applyRequestInterceptors(options: HttpRequestOptions): Promise<HttpRequestOptions> {
  let config = { ...options };
  
  for (const interceptor of requestInterceptors) {
    config = await interceptor(config);
  }
  
  return config;
}

/**
 * åº”ç”¨å“åº”æ‹¦æˆªå™¨
 */
export async function applyResponseInterceptors<T>(response: ResponseData<T>, options: HttpRequestOptions): Promise<ResponseData<T>> {
  let result = { ...response };
  
  for (const interceptor of responseInterceptors) {
    result = await interceptor(result, options);
  }
  
  return result;
}

/**
 * åº”ç”¨é”™è¯¯æ‹¦æˆªå™¨
 */
export async function applyErrorInterceptors(error: any, options: HttpRequestOptions): Promise<any> {
  let result = error;
  
  for (const interceptor of errorInterceptors) {
    result = await interceptor(result, options);
  }
  
  return result;
}

// æ·»åŠ å¾®ä¿¡Tokenæ‹¦æˆªå™¨
addRequestInterceptor(async (options) => {
  if (options.withToken) {
    try {
      // ä¼˜å…ˆä½¿ç”¨å¾®ä¿¡token
      let token = Taro.getStorageSync('wx_token');
      
      // å¦‚æœæ²¡æœ‰å¾®ä¿¡tokenï¼Œå°è¯•ä½¿ç”¨æ™®é€štoken
      if (!token) {
        token = Taro.getStorageSync('token');
      }
      
      if (token) {
        options.headers = {
          ...options.headers,
          'X-Access-Token': token  // jeecg-bootä½¿ç”¨X-Access-Token
        };
      }
    } catch (error) {
      console.error('è·å–Tokenå¤±è´¥', error);
    }
  }
  
  return options;
});

// æ·»åŠ é»˜è®¤æ—¥å¿—æ‹¦æˆªå™¨
if (process.env.NODE_ENV === 'development') {
  // è¯·æ±‚æ—¥å¿—
  addRequestInterceptor((options) => {
    console.log(`[Request] ${options.method} ${options.url}`, options.data);
    return options;
  });
  
  // å“åº”æ—¥å¿—
  addResponseInterceptor((response, options) => {
    console.log(`[Response] ${options.method} ${options.url}`, response);
    return response;
  });
  
  // é”™è¯¯æ—¥å¿—
  addErrorInterceptor((error, options) => {
    console.error(`[Error] ${options.method} ${options.url}`, error);
    return error;
  });
}

// æ·»åŠ é»˜è®¤Tokenè¿‡æœŸå¤„ç†
addErrorInterceptor((error, options) => {
  if (error && (error.code === 401 || error.code === BUSINESS_CODE.TOKEN_EXPIRED)) {
    // æ¸…é™¤æœ¬åœ°Token
    Taro.removeStorageSync('wx_token');
    Taro.removeStorageSync('token');
    Taro.removeStorageSync('wx_user_info');
    
    // è·³è½¬åˆ°ç™»å½•é¡µ
    Taro.reLaunch({
      url: '/pages/login/index'
    });
  }
  
  return error;
});
===== End of File: interceptor.ts =====


===== File: request.ts =====
import Taro from '@tarojs/taro';
import type { HttpRequestOptions, ResponseData } from './types';
import { DEFAULT_CONFIG, BUSINESS_CODE } from './config';
import { applyRequestInterceptors, applyResponseInterceptors, applyErrorInterceptors } from './interceptor';
import { handleRequestError, handleBusinessError } from './errorHandler';
import { generateCacheKey, getCacheData, setCacheData, isCacheValid } from './cache';

// è¯·æ±‚è®¡æ•°å™¨
let loadingCount = 0;

/**
 * æ˜¾ç¤ºåŠ è½½æç¤º
 */
function showLoading(text: string): void {
  loadingCount++;
  
  if (loadingCount === 1) {
    Taro.showLoading({ title: text });
  }
}

/**
 * éšè—åŠ è½½æç¤º
 */
function hideLoading(): void {
  loadingCount--;
  
  if (loadingCount === 0) {
    Taro.hideLoading();
  }
}

/**
 * å»¶è¿Ÿå‡½æ•°
 */
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * ç»Ÿä¸€è¯·æ±‚å‡½æ•°
 */
export async function request<T = any>(options: HttpRequestOptions): Promise<T> {
  // åˆå¹¶é…ç½®
  const config = { ...DEFAULT_CONFIG, ...options };
  const { url, method = 'GET', data, baseURL, showLoading: shouldShowLoading, loadingText, useCache, cacheTime, retry, retryDelay } = config;
  
  // å®Œæ•´URL
  const fullUrl = url.startsWith('http') ? url : `${baseURL}${url.startsWith('/') ? url : `/${url}`}`;
  
  // æ£€æŸ¥ç¼“å­˜
  if (useCache && method === 'GET') {
    const cacheKey = generateCacheKey(fullUrl, data);
    const cached = getCacheData<T>(cacheKey);
    
    if (cached && isCacheValid(cached, cacheTime || DEFAULT_CONFIG.cacheTime || 0)) {
      return cached.data;
    }
  }
  
  // è¯·æ±‚å‰å¤„ç†
  let requestConfig = await applyRequestInterceptors({ ...config, url: fullUrl });
  
  // é‡è¯•è®¡æ•°
  let retryCount = retry || 0;
  
  // æ˜¾ç¤ºåŠ è½½æç¤º
  if (shouldShowLoading) {
    showLoading(loadingText || 'åŠ è½½ä¸­');
  }
  
  try {
    // å‘é€è¯·æ±‚
    const executeRequest = async (): Promise<T> => {
      try {
        const response = await Taro.request({
          url: fullUrl,
          data: requestConfig.data,
          method: requestConfig.method as any,
          header: requestConfig.headers,
          timeout: requestConfig.timeout
        });
        
        // HTTPçŠ¶æ€æ£€æŸ¥
        if (response.statusCode !== 200) {
          throw { statusCode: response.statusCode };
        }
        
        // jeecg-bootå“åº”æ ¼å¼å¤„ç†
        const responseData = response.data as any;
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºjeecg-bootæ ¼å¼çš„å“åº”
        if (responseData && typeof responseData === 'object') {
          // å¦‚æœæœ‰successå­—æ®µä¸”ä¸ºfalseï¼Œè¡¨ç¤ºä¸šåŠ¡å¤±è´¥
          if ('success' in responseData && responseData.success === false) {
            throw handleBusinessError(responseData);
          }
          
          // å¦‚æœæœ‰codeå­—æ®µä¸”ä¸æ˜¯æˆåŠŸçŠ¶æ€ç 
          if ('code' in responseData && responseData.code !== BUSINESS_CODE.SUCCESS) {
            throw handleBusinessError(responseData);
          }
          
          // å“åº”æ‹¦æˆªå¤„ç†
          const processedResponse = await applyResponseInterceptors(responseData, requestConfig);
          
          // æå–å®é™…æ•°æ®
          let actualData: T;
          
          if (processedResponse.result !== undefined) {
            actualData = processedResponse.result as T;
          } else if (processedResponse.data !== undefined) {
            actualData = processedResponse.data as T;
          } else {
            actualData = processedResponse as T;
          }
          
          // è®¾ç½®ç¼“å­˜
          if (useCache && method === 'GET') {
            const cacheKey = generateCacheKey(fullUrl, data);
            setCacheData(cacheKey, actualData);
          }
          
          return actualData;
        }
        
        return responseData as T;
      } catch (error) {
        // è¯·æ±‚å¤±è´¥ä½†è¿˜æœ‰é‡è¯•æ¬¡æ•°
        if (retryCount > 0) {
          retryCount--;
          // å»¶è¿Ÿåé‡è¯•
          await delay(retryDelay || DEFAULT_CONFIG.retryDelay || 1000);
          return executeRequest();
        }
        
        // é‡è¯•æ¬¡æ•°ç”¨å®Œï¼Œå‘ä¸ŠæŠ›å‡ºé”™è¯¯
        throw error;
      }
    };
    
    return await executeRequest();
  } catch (error) {
    // é”™è¯¯å¤„ç†
    const processedError = await applyErrorInterceptors(error, requestConfig);
    throw handleRequestError(processedError, requestConfig);
  } finally {
    // éšè—åŠ è½½æç¤º
    if (shouldShowLoading) {
      hideLoading();
    }
  }
}
===== End of File: request.ts =====


===== File: types.ts =====
// è¯·æ±‚æ–¹æ³•ç±»å‹
export type RequestMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

// è¯·æ±‚é…ç½®
export interface HttpRequestConfig {
  // åŸºç¡€URL
  baseURL?: string;
  // æ˜¯å¦æ˜¾ç¤ºåŠ è½½æç¤º
  showLoading?: boolean;
  // åŠ è½½æç¤ºæ–‡å­—
  loadingText?: string;
  // æ˜¯å¦æ˜¾ç¤ºé”™è¯¯æç¤º
  showErrorToast?: boolean;
  // è¯·æ±‚å¤´
  headers?: Record<string, string>;
  // è¶…æ—¶æ—¶é—´(ms)
  timeout?: number;
  // æ˜¯å¦ä½¿ç”¨ç¼“å­˜(ä»…GETè¯·æ±‚)
  useCache?: boolean;
  // ç¼“å­˜æ—¶é—´(ms)
  cacheTime?: number;
  // é‡è¯•æ¬¡æ•°
  retry?: number;
  // é‡è¯•å»¶è¿Ÿ(ms)
  retryDelay?: number;
  // æ˜¯å¦è‡ªåŠ¨æºå¸¦token
  withToken?: boolean;
}

// è¯·æ±‚å‚æ•° - é‡å‘½åé¿å…å†²çª
export interface HttpRequestOptions extends HttpRequestConfig {
  // è¯·æ±‚åœ°å€
  url: string;
  // è¯·æ±‚æ–¹æ³•
  method?: RequestMethod;
  // è¯·æ±‚æ•°æ®
  data?: any;
}

// jeecg-bootå“åº”æ•°æ®ç»“æ„
export interface ResponseData<T = any> {
  success?: boolean;  // jeecg-bootæˆåŠŸæ ‡è¯†
  code?: number;      // çŠ¶æ€ç 
  message?: string;   // æ¶ˆæ¯
  result?: T;         // jeecg-bootæ•°æ®å­—æ®µ
  data?: T;          // é€šç”¨æ•°æ®å­—æ®µ
  timestamp?: number; // æ—¶é—´æˆ³
}

// ç¼“å­˜æ•°æ®ç»“æ„
export interface CacheData<T = any> {
  data: T;
  timestamp: number;
}

// é”™è¯¯ä¿¡æ¯ç»“æ„
export interface RequestError {
  code: number;
  message: string;
  data?: any;
}

// è¯·æ±‚æ‹¦æˆªå™¨ - ä½¿ç”¨é‡å‘½ååçš„ç±»å‹
export type RequestInterceptor = (options: HttpRequestOptions) => HttpRequestOptions | Promise<HttpRequestOptions>;

// å“åº”æ‹¦æˆªå™¨
export type ResponseInterceptor = <T>(response: ResponseData<T>, options: HttpRequestOptions) => ResponseData<T> | Promise<ResponseData<T>>;

// é”™è¯¯æ‹¦æˆªå™¨
export type ErrorInterceptor = (error: any, options: HttpRequestOptions) => any;
===== End of File: types.ts =====

