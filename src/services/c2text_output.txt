📁 services
  📁 api
    📁 cases
      📄 casesApi.ts
      📄 types.ts
    📁 contact
      📄 contactApi.ts
      📄 types.ts
    📁 index
      📄 indexApi.ts
      📄 types.ts
    📁 product
      📄 coatingApi.ts
      📄 types.ts
  📁 http
    📄 cache.ts
    📄 config.ts
    📄 errorHandler.ts
    📄 index.ts
    📄 interceptor.ts
    📄 request.ts
    📄 types.ts

===== File: api\cases\casesApi.ts =====
import { CaseData, CaseQueryParams, CaseApiResponse, CasesApiResponse } from './types';
import { mockCases, PAGE_SIZE, CITY_TYPES } from './data';

// API端点常量
const ENDPOINTS = {
  GET_CASES: '/cases',
  GET_CASE_DETAIL: '/cases/:id',
} as const;

// API延迟配置
const API_DELAYS = {
  LIST: 800,
  DETAIL: 500,
} as const;

/**
 * 模拟API延迟
 */
const simulateDelay = (ms: number): Promise<void> => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

/**
 * 获取案例列表
 */
export const getCases = async ({
  city = 'all',
  keyword = '',
  page = 1,
  pageSize = PAGE_SIZE
}: CaseQueryParams): Promise<CasesApiResponse> => {
  try {
    // 模拟API调用延迟
    await simulateDelay(API_DELAYS.LIST);
    
    // 过滤数据
    let filteredData = mockCases.filter(item => {
      // 城市筛选
      if (city !== 'all' && item.city !== city) return false;
      
      // 关键词搜索
      if (keyword) {
        const searchText = keyword.toLowerCase();
        const matchTitle = item.title.toLowerCase().includes(searchText);
        const matchDescription = item.description.toLowerCase().includes(searchText);
        const matchCity = item.city.toLowerCase().includes(searchText);
        
        if (!matchTitle && !matchDescription && !matchCity) return false;
      }
      
      return true;
    });
    
    // 计算分页
    const startIndex = (page - 1) * pageSize;
    const endIndex = startIndex + pageSize;
    const paginatedData = filteredData.slice(startIndex, endIndex);
    
    // 判断是否还有更多数据
    const hasMore = endIndex < filteredData.length;
    
    return {
      success: true,
      data: paginatedData,
      hasMore
    };
  } catch (error: any) {
    console.error('获取案例列表失败:', error);
    return {
      success: false,
      error: error.message || '获取案例列表失败',
      data: [],
      hasMore: false
    };
  }
};

/**
 * 根据ID获取案例详情
 */
export const getCaseDetail = async (id: number): Promise<CaseApiResponse<CaseData>> => {
  try {
    // 参数验证
    if (!id || id <= 0) {
      throw new Error('无效的案例ID');
    }
    
    // 模拟API调用延迟
    await simulateDelay(API_DELAYS.DETAIL);
    
    // 查找案例
    const caseItem = mockCases.find(item => item.id === id);
    
    if (caseItem) {
      return {
        success: true,
        data: caseItem
      };
    } else {
      throw new Error('案例不存在');
    }
  } catch (error: any) {
    console.error('获取案例详情失败:', error);
    return {
      success: false,
      error: error.message || '获取案例详情失败'
    };
  }
};

/**
 * 统一错误处理工具
 */
export const handleCasesError = (err: any): string => {
  console.error('案例API错误:', err);
  
  if (err instanceof Error) {
    return err.message;
  }
  
  if (typeof err === 'string') {
    return err;
  }
  
  return '发生未知错误，请稍后重试';
};

// 导出常量
export { mockCases, PAGE_SIZE, CITY_TYPES };

// 导出类型
export * from './types';
export * from './data';
===== End of File: api\cases\casesApi.ts =====


===== File: api\cases\types.ts =====
// 案例数据接口
export interface CaseData {
  id: number;
  title: string;
  city: string;
  description: string;
  date: string;
  images: string[];
  videos?: string[];
  content: string;
}

// 案例查询参数
export interface CaseQueryParams {
  city?: string;
  keyword?: string;
  page?: number;
  pageSize?: number;
}

// 案例API响应基础接口
export interface CaseApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

// 案例列表API响应
export interface CasesApiResponse extends CaseApiResponse<CaseData[]> {
  hasMore?: boolean;
}

// 分页信息
export interface PaginationInfo {
  currentPage: number;
  pageSize: number;
  total: number;
  totalPages: number;
}

// 城市类型
export interface CityType {
  title: string;
  value: string;
}
===== End of File: api\cases\types.ts =====


===== File: api\contact\contactApi.ts =====
import { ServiceType, ContactData, BookingFormData, ApiResponse } from './types';
import { serviceTypes, contactData } from './data';

export const getServiceTypes = async (): Promise<ApiResponse<ServiceType[]>> => {
  try {
    await new Promise(resolve => setTimeout(resolve, 300));
    
    return {
      success: true,
      data: serviceTypes
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || '获取服务类型失败'
    };
  }
};

export const getContactData = async (): Promise<ApiResponse<ContactData>> => {
  try {
    await new Promise(resolve => setTimeout(resolve, 300));
    
    return {
      success: true,
      data: contactData
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || '获取联系信息失败'
    };
  }
};

export const submitBooking = async (data: BookingFormData): Promise<ApiResponse<{ bookingId: string }>> => {
  try {
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return {
      success: true,
      data: {
        bookingId: `ZX${Date.now().toString().slice(-6)}`
      }
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || '提交预约失败'
    };
  }
};

export const handleContactError = (err: any): string => {
  console.error(err);
  return err instanceof Error ? err.message : '发生未知错误';
};

export * from './types';
export * from './data';
===== End of File: api\contact\contactApi.ts =====


===== File: api\contact\types.ts =====
export interface ServiceType {
  text: string;
  value: string;
}

export interface ContactData {
  description: string;
  phone: string[];
  wechat: string;
  address: string;
}

export interface BookingFormData {
  name: string;
  phone: string;
  serviceType: string;
  serviceTypeName: string;
  region: string[];
  address: string;
  remark: string;
}

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}
===== End of File: api\contact\types.ts =====


===== File: api\index\indexApi.ts =====
// services/api/index/indexApi.ts
import http from '../../http';
import { IndexData, ApiResponse } from './types';
import { indexData } from './data';

// API端点
const ENDPOINTS = {
  GET_INDEX_DATA: '/index',
};

/**
 * 获取首页所有数据
 */
export const getIndexData = async (): Promise<ApiResponse<IndexData>> => {
  try {
    // 替换为实际API调用当后端准备好时
    // const data = await http.get<IndexData>(ENDPOINTS.GET_INDEX_DATA);
    
    // 模拟API调用延迟
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // 返回模拟数据
    return {
      success: true,
      data: indexData
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || '获取首页数据失败'
    };
  }
};

/**
 * 首页模块错误处理工具
 */
export const handleIndexError = (err: any): string => {
  console.error('Index API Error:', err);
  return err instanceof Error ? err.message : '获取首页数据时发生未知错误';
};

// 导出类型和数据
export * from './types';
export * from './data';
===== End of File: api\index\indexApi.ts =====


===== File: api\index\types.ts =====
// services/api/index/types.ts

// 服务项接口
export interface Service {
    id: number | string;
    title: string;
    description: string;
}

// 基础案例数据接口
export interface CaseData {
    id: number;
    title: string;
    city: string;
    description: string;
    date: string;
    images: string[];
    videos?: string[];
    content: string;
}

// 精选案例接口 - 继承CaseData并添加封面图
export interface Showcase extends CaseData {
    coverImage: string; // 精选案例的封面图
}

// 联系信息接口 - 修改为支持多个电话号码
export interface ContactInfo {
    phone: string[]; // 改为数组支持多个号码
    phoneLabels?: string[]; // 可选的电话标签
    wechat: string;
}

// Banner接口
export interface Banner {
    id: string;
    imageUrl: string;
    title?: string;
    subtitle?: string;
}

// 首页数据接口
export interface IndexData {
    services: Service[];
    showcases: Showcase[];
    contactInfo: ContactInfo;
    banners: Banner[];
}

// API响应包装器
export interface ApiResponse<T> {
    success: boolean;
    data?: T;
    error?: string;
}
===== End of File: api\index\types.ts =====


===== File: api\product\coatingApi.ts =====
// 防水涂料产品API服务

import { 
  WaterproofCoating, 
  CoatingQueryParams, 
  ApiResponse, 
  CoatingListResponse, 
  CoatingDetailResponse 
} from './types';
import { mockCoatings, PAGE_SIZE } from './data';

/**
 * 获取防水涂料产品列表
 * @param params 查询参数
 * @returns 产品列表响应
 */
export const getCoatingList = async ({
  page,
  pageSize = PAGE_SIZE
}: CoatingQueryParams): Promise<CoatingListResponse> => {
  try {
    // 模拟API调用延迟
    await new Promise(resolve => setTimeout(resolve, 600));
    
    // 分页处理
    const startIndex = (page - 1) * pageSize;
    const endIndex = startIndex + pageSize;
    const paginatedData = mockCoatings.slice(startIndex, endIndex);
    
    // 判断是否还有更多数据
    const hasMore = endIndex < mockCoatings.length;
    
    return {
      success: true,
      data: paginatedData,
      hasMore
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || '获取产品列表失败',
      data: []
    };
  }
};

/**
 * 获取防水涂料产品详情
 * @param id 产品ID
 * @returns 产品详情响应
 */
export const getCoatingDetail = async (id: number): Promise<CoatingDetailResponse> => {
  try {
    // 模拟API调用延迟
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // 查找产品
    const product = mockCoatings.find(item => item.id === id);
    
    if (product) {
      return {
        success: true,
        data: product
      };
    } else {
      throw new Error('产品不存在');
    }
  } catch (error: any) {
    return {
      success: false,
      error: error.message || '获取产品详情失败'
    };
  }
};

// 导出常量
export { PAGE_SIZE } from './data';

// 导出类型
export * from './types';
===== End of File: api\product\coatingApi.ts =====


===== File: api\product\types.ts =====
// 防水涂料产品类型定义

// 防水涂料产品类型
export interface WaterproofCoating {
  id: number;
  title: string;             // 产品名称
  type: string;              // 产品规格
  specifications: string;    // 全国统一零售价
  description: string;       // 产品简介
  content: string;           // 适用范围
  images: string[];          // 产品图片列表
}

// 分页查询参数
export interface CoatingQueryParams {
  page: number;
  pageSize: number;
}

// API响应基础接口
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

// 产品列表API响应
export interface CoatingListResponse extends ApiResponse<WaterproofCoating[]> {
  hasMore?: boolean; // 是否还有更多数据
}

// 产品详情API响应
export interface CoatingDetailResponse extends ApiResponse<WaterproofCoating> {}
===== End of File: api\product\types.ts =====


===== File: http\cache.ts =====
import Taro from '@tarojs/taro';
import type { CacheData } from './types';

// 缓存键前缀
const CACHE_PREFIX = 'http_cache_';

/**
 * 生成缓存键
 */
export function generateCacheKey(url: string, data?: any): string {
  return `${CACHE_PREFIX}${url}_${JSON.stringify(data || {})}`;
}

/**
 * 获取缓存数据
 */
export function getCacheData<T>(key: string): CacheData<T> | null {
  try {
    const cacheData = Taro.getStorageSync(key);
    return cacheData ? JSON.parse(cacheData) : null;
  } catch (error) {
    console.error('获取缓存数据失败', error);
    return null;
  }
}

/**
 * 设置缓存数据
 */
export function setCacheData<T>(key: string, data: T): void {
    try {
      const cacheData: CacheData<T> = {
        data,
        timestamp: Date.now()
      };
      
      Taro.setStorageSync(key, JSON.stringify(cacheData));
    } catch (error) {
      console.error('设置缓存数据失败', error);
    }
  }

/**
 * 清除缓存数据
 */
export function clearCacheData(key: string): void {
  try {
    Taro.removeStorageSync(key);
  } catch (error) {
    console.error('清除缓存数据失败', error);
  }
}

/**
 * 清除所有HTTP缓存
 */
export function clearAllCache(): void {
  try {
    const storageInfo = Taro.getStorageInfoSync();
    const keys = storageInfo.keys || [];
    
    keys.forEach(key => {
      if (key.startsWith(CACHE_PREFIX)) {
        Taro.removeStorageSync(key);
      }
    });
  } catch (error) {
    console.error('清除所有缓存失败', error);
  }
}

/**
 * 检查缓存是否有效
 */
export function isCacheValid<T>(cache: CacheData<T>, cacheTime: number): boolean {
  if (!cache || !cache.timestamp) return false;
  
  return Date.now() - cache.timestamp < cacheTime;
}
===== End of File: http\cache.ts =====


===== File: http\config.ts =====
import type { RequestConfig } from './types';

// API基础URL
export const API_BASE_URL = {
  // 开发环境
  development: 'https://dev-api.example.com/v1',
  // 生产环境
  production: 'https://api.example.com/v1'
};

// 环境判断
export const ENV = process.env.NODE_ENV || 'development';

// HTTP状态码
export const HTTP_STATUS = {
  SUCCESS: 200,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  SERVER_ERROR: 500
};

// 业务状态码
export const BUSINESS_CODE = {
  SUCCESS: 0,           // 成功
  TOKEN_EXPIRED: 10001, // token过期
  PARAM_ERROR: 10002,   // 参数错误
  SERVER_ERROR: 50000   // 服务器错误
};

// 默认请求配置
export const DEFAULT_CONFIG: RequestConfig = {
  baseURL: API_BASE_URL[ENV],
  showLoading: true,
  loadingText: '加载中',
  showErrorToast: true,
  headers: {
    'Content-Type': 'application/json'
  },
  timeout: 10000,       // 10秒
  useCache: false,
  cacheTime: 5 * 60 * 1000,  // 5分钟
  retry: 0,
  retryDelay: 1000,
  withToken: true
};
===== End of File: http\config.ts =====


===== File: http\errorHandler.ts =====
import Taro from '@tarojs/taro';
import { HTTP_STATUS, BUSINESS_CODE } from './config';
import type { RequestError, RequestOptions } from './types';

/**
 * 处理HTTP状态错误
 */
export function handleHttpError(statusCode: number): RequestError {
  let message = '未知错误';
  
  switch (statusCode) {
    case HTTP_STATUS.BAD_REQUEST:
      message = '请求参数错误';
      break;
    case HTTP_STATUS.UNAUTHORIZED:
      message = '未授权，请登录';
      break;
    case HTTP_STATUS.FORBIDDEN:
      message = '没有权限访问';
      break;
    case HTTP_STATUS.NOT_FOUND:
      message = '请求资源不存在';
      break;
    case HTTP_STATUS.SERVER_ERROR:
      message = '服务器内部错误';
      break;
    default:
      message = `HTTP错误 (${statusCode})`;
  }
  
  return {
    code: statusCode,
    message
  };
}

/**
 * 处理业务状态错误
 */
export function handleBusinessError<T>(response: { code: number; message: string; data?: T }): RequestError {
  let message = response.message || '未知错误';
  
  switch (response.code) {
    case BUSINESS_CODE.TOKEN_EXPIRED:
      message = '登录已过期，请重新登录';
      break;
    case BUSINESS_CODE.PARAM_ERROR:
      message = '参数错误';
      break;
    case BUSINESS_CODE.SERVER_ERROR:
      message = '服务器内部错误';
      break;
  }
  
  return {
    code: response.code,
    message,
    data: response.data
  };
}

/**
 * 处理网络错误
 */
export function handleNetworkError(error: any): RequestError {
  let message = '网络异常';
  
  if (error?.errMsg) {
    if (error.errMsg.includes('timeout')) {
      message = '请求超时，请检查网络';
    } else if (error.errMsg.includes('fail')) {
      message = '网络连接失败，请检查网络设置';
    }
  }
  
  return {
    code: -1,
    message
  };
}

/**
 * 综合错误处理
 */
export function handleRequestError(error: any, options: RequestOptions): RequestError {
  // 已格式化的错误
  if (error && typeof error === 'object' && 'code' in error && 'message' in error) {
    if (options.showErrorToast) {
      Taro.showToast({
        title: error.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return error as RequestError;
  }
  
  // HTTP错误
  if (error && typeof error === 'object' && 'statusCode' in error) {
    const httpError = handleHttpError(error.statusCode);
    
    if (options.showErrorToast) {
      Taro.showToast({
        title: httpError.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return httpError;
  }
  
  // 网络错误
  if (error && typeof error === 'object' && 'errMsg' in error) {
    const networkError = handleNetworkError(error);
    
    if (options.showErrorToast) {
      Taro.showToast({
        title: networkError.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return networkError;
  }
  
  // 其他错误
  const unknownError: RequestError = {
    code: -1,
    message: typeof error === 'string' ? error : '未知错误'
  };
  
  if (options.showErrorToast) {
    Taro.showToast({
      title: unknownError.message,
      icon: 'none',
      duration: 2000
    });
  }
  
  return unknownError;
}
===== End of File: http\errorHandler.ts =====


===== File: http\index.ts =====
import { request } from './request';
import type { RequestOptions} from './types';
import { addRequestInterceptor, addResponseInterceptor, addErrorInterceptor } from './interceptor';
import { clearAllCache, clearCacheData } from './cache';

/**
 * HTTP客户端
 */
const http = {
  /**
   * 发送GET请求
   */
  get: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'GET', data, ...options }),
  
  /**
   * 发送POST请求
   */  
  post: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'POST', data, ...options }),
  
  /**
   * 发送PUT请求
   */
  put: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'PUT', data, ...options }),
  
  /**
   * 发送DELETE请求
   */
  delete: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'DELETE', data, ...options }),
  
  /**
   * 原始请求方法
   */
  request,
  
  /**
   * 清除指定缓存
   */
  clearCache: clearCacheData,
  
  /**
   * 清除所有缓存
   */
  clearAllCache,
  
  /**
   * 添加请求拦截器
   */
  addRequestInterceptor,
  
  /**
   * 添加响应拦截器
   */
  addResponseInterceptor,
  
  /**
   * 添加错误拦截器
   */
  addErrorInterceptor
};

export default http;

// 导出类型
export * from './types';
export { DEFAULT_CONFIG } from './config';
===== End of File: http\index.ts =====


===== File: http\interceptor.ts =====
import Taro from '@tarojs/taro';
import type { RequestInterceptor, ResponseInterceptor, ErrorInterceptor, RequestOptions, ResponseData } from './types';
import { BUSINESS_CODE } from './config';

// 请求拦截器数组
const requestInterceptors: RequestInterceptor[] = [];

// 响应拦截器数组
const responseInterceptors: ResponseInterceptor[] = [];

// 错误拦截器数组
const errorInterceptors: ErrorInterceptor[] = [];

/**
 * 添加请求拦截器
 */
export function addRequestInterceptor(interceptor: RequestInterceptor): void {
  requestInterceptors.push(interceptor);
}

/**
 * 添加响应拦截器
 */
export function addResponseInterceptor(interceptor: ResponseInterceptor): void {
  responseInterceptors.push(interceptor);
}

/**
 * 添加错误拦截器
 */
export function addErrorInterceptor(interceptor: ErrorInterceptor): void {
  errorInterceptors.push(interceptor);
}

/**
 * 应用请求拦截器
 */
export async function applyRequestInterceptors(options: RequestOptions): Promise<RequestOptions> {
  let config = { ...options };
  
  for (const interceptor of requestInterceptors) {
    config = await interceptor(config);
  }
  
  return config;
}

/**
 * 应用响应拦截器
 */
export async function applyResponseInterceptors<T>(response: ResponseData<T>, options: RequestOptions): Promise<ResponseData<T>> {
  let result = { ...response };
  
  for (const interceptor of responseInterceptors) {
    result = await interceptor(result, options);
  }
  
  return result;
}

/**
 * 应用错误拦截器
 */
export async function applyErrorInterceptors(error: any, options: RequestOptions): Promise<any> {
  let result = error;
  
  for (const interceptor of errorInterceptors) {
    result = await interceptor(result, options);
  }
  
  return result;
}

// 添加默认Token拦截器
addRequestInterceptor(async (options) => {
  if (options.withToken) {
    try {
      const token = Taro.getStorageSync('token');
      if (token) {
        options.headers = {
          ...options.headers,
          'Authorization': `Bearer ${token}`
        };
      }
    } catch (error) {
      console.error('获取Token失败', error);
    }
  }
  
  return options;
});

// 添加默认日志拦截器
if (process.env.NODE_ENV === 'development') {
  // 请求日志
  addRequestInterceptor((options) => {
    console.log(`[Request] ${options.method} ${options.url}`, options.data);
    return options;
  });
  
  // 响应日志
  addResponseInterceptor((response, options) => {
    console.log(`[Response] ${options.method} ${options.url}`, response);
    return response;
  });
  
  // 错误日志
  addErrorInterceptor((error, options) => {
    console.error(`[Error] ${options.method} ${options.url}`, error);
    return error;
  });
}

// 添加默认Token过期处理
addErrorInterceptor((error) => {
  if (error && error.code === BUSINESS_CODE.TOKEN_EXPIRED) {
    // 清除本地Token
    Taro.removeStorageSync('token');
    
    // 跳转到登录页
    Taro.navigateTo({
      url: '/pages/login/index'
    });
  }
  
  return error;
});
===== End of File: http\interceptor.ts =====


===== File: http\request.ts =====
import Taro from '@tarojs/taro';
import type { RequestOptions, ResponseData } from './types';
import { DEFAULT_CONFIG, BUSINESS_CODE } from './config';
import { applyRequestInterceptors, applyResponseInterceptors, applyErrorInterceptors } from './interceptor';
import { handleRequestError, handleBusinessError } from './errorHandler';
import { generateCacheKey, getCacheData, setCacheData, isCacheValid } from './cache';

// 请求计数器
let loadingCount = 0;

/**
 * 显示加载提示
 */
function showLoading(text: string): void {
  loadingCount++;
  
  if (loadingCount === 1) {
    Taro.showLoading({ title: text });
  }
}

/**
 * 隐藏加载提示
 */
function hideLoading(): void {
  loadingCount--;
  
  if (loadingCount === 0) {
    Taro.hideLoading();
  }
}

/**
 * 延迟函数
 */
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * 统一请求函数
 */
export async function request<T = any>(options: RequestOptions): Promise<T> {
  // 合并配置
  const config = { ...DEFAULT_CONFIG, ...options };
  const { url, method = 'GET', data, baseURL, showLoading: shouldShowLoading, loadingText, useCache, cacheTime, retry, retryDelay } = config;
  
  // 完整URL
  const fullUrl = url.startsWith('http') ? url : `${baseURL}${url.startsWith('/') ? url : `/${url}`}`;
  
  // 检查缓存
  if (useCache && method === 'GET') {
    const cacheKey = generateCacheKey(fullUrl, data);
    const cached = getCacheData<T>(cacheKey);
    
    if (cached && isCacheValid(cached, cacheTime || DEFAULT_CONFIG.cacheTime || 0)) {
      return cached.data;
    }
  }
  
  // 请求前处理
  let requestConfig = await applyRequestInterceptors({ ...config, url: fullUrl });
  
  // 重试计数
  let retryCount = retry || 0;
  
  // 显示加载提示
  if (shouldShowLoading) {
    showLoading(loadingText || '加载中');
  }
  
  try {
    // 发送请求
    const executeRequest = async (): Promise<T> => {
      try {
        const response = await Taro.request({
          url: fullUrl,
          data: requestConfig.data,
          method: requestConfig.method as any,
          header: requestConfig.headers,
          timeout: requestConfig.timeout
        });
        
        // HTTP状态检查
        if (response.statusCode !== 200) {
          throw { statusCode: response.statusCode };
        }
        
        // 业务状态检查
        const responseData = response.data as ResponseData<T>;
        
        if (responseData.code !== BUSINESS_CODE.SUCCESS) {
          throw handleBusinessError(responseData);
        }
        
        // 响应拦截处理
        const processedResponse = await applyResponseInterceptors(responseData, requestConfig);
        
        // 设置缓存
        if (useCache && method === 'GET') {
          const cacheKey = generateCacheKey(fullUrl, data);
          setCacheData(cacheKey, processedResponse.data);
        }
        
        return processedResponse.data;
      } catch (error) {
        // 请求失败但还有重试次数
        if (retryCount > 0) {
          retryCount--;
          // 延迟后重试
          await delay(retryDelay || DEFAULT_CONFIG.retryDelay || 1000);
          return executeRequest();
        }
        
        // 重试次数用完，向上抛出错误
        throw error;
      }
    };
    
    return await executeRequest();
  } catch (error) {
    // 错误处理
    const processedError = await applyErrorInterceptors(error, requestConfig);
    throw handleRequestError(processedError, requestConfig);
  } finally {
    // 隐藏加载提示
    if (shouldShowLoading) {
      hideLoading();
    }
  }
}
===== End of File: http\request.ts =====


===== File: http\types.ts =====
// 请求方法类型
export type RequestMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

// 请求配置
export interface RequestConfig {
  // 基础URL
  baseURL?: string;
  // 是否显示加载提示
  showLoading?: boolean;
  // 加载提示文字
  loadingText?: string;
  // 是否显示错误提示
  showErrorToast?: boolean;
  // 请求头
  headers?: Record<string, string>;
  // 超时时间(ms)
  timeout?: number;
  // 是否使用缓存(仅GET请求)
  useCache?: boolean;
  // 缓存时间(ms)
  cacheTime?: number;
  // 重试次数
  retry?: number;
  // 重试延迟(ms)
  retryDelay?: number;
  // 是否自动携带token
  withToken?: boolean;
}

// 请求参数
export interface RequestOptions extends RequestConfig {
  // 请求地址
  url: string;
  // 请求方法
  method?: RequestMethod;
  // 请求数据
  data?: any;
}

// 响应数据结构
export interface ResponseData<T = any> {
  code: number;
  message: string;
  data: T;
}

// 缓存数据结构
export interface CacheData<T = any> {
  data: T;
  timestamp: number;
}

// 错误信息结构
export interface RequestError {
  code: number;
  message: string;
  data?: any;
}

// 请求拦截器
export type RequestInterceptor = (options: RequestOptions) => RequestOptions | Promise<RequestOptions>;

// 响应拦截器
export type ResponseInterceptor = <T>(response: ResponseData<T>, options: RequestOptions) => ResponseData<T> | Promise<ResponseData<T>>;

// 错误拦截器
export type ErrorInterceptor = (error: any, options: RequestOptions) => any;
===== End of File: http\types.ts =====

