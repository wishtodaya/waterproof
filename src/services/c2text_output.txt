ğŸ“ services
  ğŸ“ api
    ğŸ“ cases
      ğŸ“„ casesApi.ts
      ğŸ“„ types.ts
    ğŸ“ contact
      ğŸ“„ contactApi.ts
      ğŸ“„ types.ts
    ğŸ“ index
      ğŸ“„ indexApi.ts
      ğŸ“„ types.ts
    ğŸ“ product
      ğŸ“„ coatingApi.ts
      ğŸ“„ types.ts
  ğŸ“ http
    ğŸ“„ cache.ts
    ğŸ“„ config.ts
    ğŸ“„ errorHandler.ts
    ğŸ“„ index.ts
    ğŸ“„ interceptor.ts
    ğŸ“„ request.ts
    ğŸ“„ types.ts

===== File: api\cases\casesApi.ts =====
import { CaseData, CaseQueryParams, CaseApiResponse, CasesApiResponse } from './types';
import { mockCases, PAGE_SIZE, CITY_TYPES } from './data';

// APIç«¯ç‚¹å¸¸é‡
const ENDPOINTS = {
  GET_CASES: '/cases',
  GET_CASE_DETAIL: '/cases/:id',
} as const;

// APIå»¶è¿Ÿé…ç½®
const API_DELAYS = {
  LIST: 800,
  DETAIL: 500,
} as const;

/**
 * æ¨¡æ‹ŸAPIå»¶è¿Ÿ
 */
const simulateDelay = (ms: number): Promise<void> => {
  return new Promise(resolve => setTimeout(resolve, ms));
};

/**
 * è·å–æ¡ˆä¾‹åˆ—è¡¨
 */
export const getCases = async ({
  city = 'all',
  keyword = '',
  page = 1,
  pageSize = PAGE_SIZE
}: CaseQueryParams): Promise<CasesApiResponse> => {
  try {
    // æ¨¡æ‹ŸAPIè°ƒç”¨å»¶è¿Ÿ
    await simulateDelay(API_DELAYS.LIST);
    
    // è¿‡æ»¤æ•°æ®
    let filteredData = mockCases.filter(item => {
      // åŸå¸‚ç­›é€‰
      if (city !== 'all' && item.city !== city) return false;
      
      // å…³é”®è¯æœç´¢
      if (keyword) {
        const searchText = keyword.toLowerCase();
        const matchTitle = item.title.toLowerCase().includes(searchText);
        const matchDescription = item.description.toLowerCase().includes(searchText);
        const matchCity = item.city.toLowerCase().includes(searchText);
        
        if (!matchTitle && !matchDescription && !matchCity) return false;
      }
      
      return true;
    });
    
    // è®¡ç®—åˆ†é¡µ
    const startIndex = (page - 1) * pageSize;
    const endIndex = startIndex + pageSize;
    const paginatedData = filteredData.slice(startIndex, endIndex);
    
    // åˆ¤æ–­æ˜¯å¦è¿˜æœ‰æ›´å¤šæ•°æ®
    const hasMore = endIndex < filteredData.length;
    
    return {
      success: true,
      data: paginatedData,
      hasMore
    };
  } catch (error: any) {
    console.error('è·å–æ¡ˆä¾‹åˆ—è¡¨å¤±è´¥:', error);
    return {
      success: false,
      error: error.message || 'è·å–æ¡ˆä¾‹åˆ—è¡¨å¤±è´¥',
      data: [],
      hasMore: false
    };
  }
};

/**
 * æ ¹æ®IDè·å–æ¡ˆä¾‹è¯¦æƒ…
 */
export const getCaseDetail = async (id: number): Promise<CaseApiResponse<CaseData>> => {
  try {
    // å‚æ•°éªŒè¯
    if (!id || id <= 0) {
      throw new Error('æ— æ•ˆçš„æ¡ˆä¾‹ID');
    }
    
    // æ¨¡æ‹ŸAPIè°ƒç”¨å»¶è¿Ÿ
    await simulateDelay(API_DELAYS.DETAIL);
    
    // æŸ¥æ‰¾æ¡ˆä¾‹
    const caseItem = mockCases.find(item => item.id === id);
    
    if (caseItem) {
      return {
        success: true,
        data: caseItem
      };
    } else {
      throw new Error('æ¡ˆä¾‹ä¸å­˜åœ¨');
    }
  } catch (error: any) {
    console.error('è·å–æ¡ˆä¾‹è¯¦æƒ…å¤±è´¥:', error);
    return {
      success: false,
      error: error.message || 'è·å–æ¡ˆä¾‹è¯¦æƒ…å¤±è´¥'
    };
  }
};

/**
 * ç»Ÿä¸€é”™è¯¯å¤„ç†å·¥å…·
 */
export const handleCasesError = (err: any): string => {
  console.error('æ¡ˆä¾‹APIé”™è¯¯:', err);
  
  if (err instanceof Error) {
    return err.message;
  }
  
  if (typeof err === 'string') {
    return err;
  }
  
  return 'å‘ç”ŸæœªçŸ¥é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•';
};

// å¯¼å‡ºå¸¸é‡
export { mockCases, PAGE_SIZE, CITY_TYPES };

// å¯¼å‡ºç±»å‹
export * from './types';
export * from './data';
===== End of File: api\cases\casesApi.ts =====


===== File: api\cases\types.ts =====
// æ¡ˆä¾‹æ•°æ®æ¥å£
export interface CaseData {
  id: number;
  title: string;
  city: string;
  description: string;
  date: string;
  images: string[];
  videos?: string[];
  content: string;
}

// æ¡ˆä¾‹æŸ¥è¯¢å‚æ•°
export interface CaseQueryParams {
  city?: string;
  keyword?: string;
  page?: number;
  pageSize?: number;
}

// æ¡ˆä¾‹APIå“åº”åŸºç¡€æ¥å£
export interface CaseApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

// æ¡ˆä¾‹åˆ—è¡¨APIå“åº”
export interface CasesApiResponse extends CaseApiResponse<CaseData[]> {
  hasMore?: boolean;
}

// åˆ†é¡µä¿¡æ¯
export interface PaginationInfo {
  currentPage: number;
  pageSize: number;
  total: number;
  totalPages: number;
}

// åŸå¸‚ç±»å‹
export interface CityType {
  title: string;
  value: string;
}
===== End of File: api\cases\types.ts =====


===== File: api\contact\contactApi.ts =====
import { ServiceType, ContactData, BookingFormData, ApiResponse } from './types';
import { serviceTypes, contactData } from './data';

export const getServiceTypes = async (): Promise<ApiResponse<ServiceType[]>> => {
  try {
    await new Promise(resolve => setTimeout(resolve, 300));
    
    return {
      success: true,
      data: serviceTypes
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || 'è·å–æœåŠ¡ç±»å‹å¤±è´¥'
    };
  }
};

export const getContactData = async (): Promise<ApiResponse<ContactData>> => {
  try {
    await new Promise(resolve => setTimeout(resolve, 300));
    
    return {
      success: true,
      data: contactData
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || 'è·å–è”ç³»ä¿¡æ¯å¤±è´¥'
    };
  }
};

export const submitBooking = async (data: BookingFormData): Promise<ApiResponse<{ bookingId: string }>> => {
  try {
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return {
      success: true,
      data: {
        bookingId: `ZX${Date.now().toString().slice(-6)}`
      }
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || 'æäº¤é¢„çº¦å¤±è´¥'
    };
  }
};

export const handleContactError = (err: any): string => {
  console.error(err);
  return err instanceof Error ? err.message : 'å‘ç”ŸæœªçŸ¥é”™è¯¯';
};

export * from './types';
export * from './data';
===== End of File: api\contact\contactApi.ts =====


===== File: api\contact\types.ts =====
export interface ServiceType {
  text: string;
  value: string;
}

export interface ContactData {
  description: string;
  phone: string[];
  wechat: string;
  address: string;
}

export interface BookingFormData {
  name: string;
  phone: string;
  serviceType: string;
  serviceTypeName: string;
  region: string[];
  address: string;
  remark: string;
}

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}
===== End of File: api\contact\types.ts =====


===== File: api\index\indexApi.ts =====
// services/api/index/indexApi.ts
import http from '../../http';
import { IndexData, ApiResponse } from './types';
import { indexData } from './data';

// APIç«¯ç‚¹
const ENDPOINTS = {
  GET_INDEX_DATA: '/index',
};

/**
 * è·å–é¦–é¡µæ‰€æœ‰æ•°æ®
 */
export const getIndexData = async (): Promise<ApiResponse<IndexData>> => {
  try {
    // æ›¿æ¢ä¸ºå®é™…APIè°ƒç”¨å½“åç«¯å‡†å¤‡å¥½æ—¶
    // const data = await http.get<IndexData>(ENDPOINTS.GET_INDEX_DATA);
    
    // æ¨¡æ‹ŸAPIè°ƒç”¨å»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // è¿”å›æ¨¡æ‹Ÿæ•°æ®
    return {
      success: true,
      data: indexData
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || 'è·å–é¦–é¡µæ•°æ®å¤±è´¥'
    };
  }
};

/**
 * é¦–é¡µæ¨¡å—é”™è¯¯å¤„ç†å·¥å…·
 */
export const handleIndexError = (err: any): string => {
  console.error('Index API Error:', err);
  return err instanceof Error ? err.message : 'è·å–é¦–é¡µæ•°æ®æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯';
};

// å¯¼å‡ºç±»å‹å’Œæ•°æ®
export * from './types';
export * from './data';
===== End of File: api\index\indexApi.ts =====


===== File: api\index\types.ts =====
// services/api/index/types.ts

// æœåŠ¡é¡¹æ¥å£
export interface Service {
    id: number | string;
    title: string;
    description: string;
}

// åŸºç¡€æ¡ˆä¾‹æ•°æ®æ¥å£
export interface CaseData {
    id: number;
    title: string;
    city: string;
    description: string;
    date: string;
    images: string[];
    videos?: string[];
    content: string;
}

// ç²¾é€‰æ¡ˆä¾‹æ¥å£ - ç»§æ‰¿CaseDataå¹¶æ·»åŠ å°é¢å›¾
export interface Showcase extends CaseData {
    coverImage: string; // ç²¾é€‰æ¡ˆä¾‹çš„å°é¢å›¾
}

// è”ç³»ä¿¡æ¯æ¥å£ - ä¿®æ”¹ä¸ºæ”¯æŒå¤šä¸ªç”µè¯å·ç 
export interface ContactInfo {
    phone: string[]; // æ”¹ä¸ºæ•°ç»„æ”¯æŒå¤šä¸ªå·ç 
    phoneLabels?: string[]; // å¯é€‰çš„ç”µè¯æ ‡ç­¾
    wechat: string;
}

// Banneræ¥å£
export interface Banner {
    id: string;
    imageUrl: string;
    title?: string;
    subtitle?: string;
}

// é¦–é¡µæ•°æ®æ¥å£
export interface IndexData {
    services: Service[];
    showcases: Showcase[];
    contactInfo: ContactInfo;
    banners: Banner[];
}

// APIå“åº”åŒ…è£…å™¨
export interface ApiResponse<T> {
    success: boolean;
    data?: T;
    error?: string;
}
===== End of File: api\index\types.ts =====


===== File: api\product\coatingApi.ts =====
// é˜²æ°´æ¶‚æ–™äº§å“APIæœåŠ¡

import { 
  WaterproofCoating, 
  CoatingQueryParams, 
  ApiResponse, 
  CoatingListResponse, 
  CoatingDetailResponse 
} from './types';
import { mockCoatings, PAGE_SIZE } from './data';

/**
 * è·å–é˜²æ°´æ¶‚æ–™äº§å“åˆ—è¡¨
 * @param params æŸ¥è¯¢å‚æ•°
 * @returns äº§å“åˆ—è¡¨å“åº”
 */
export const getCoatingList = async ({
  page,
  pageSize = PAGE_SIZE
}: CoatingQueryParams): Promise<CoatingListResponse> => {
  try {
    // æ¨¡æ‹ŸAPIè°ƒç”¨å»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 600));
    
    // åˆ†é¡µå¤„ç†
    const startIndex = (page - 1) * pageSize;
    const endIndex = startIndex + pageSize;
    const paginatedData = mockCoatings.slice(startIndex, endIndex);
    
    // åˆ¤æ–­æ˜¯å¦è¿˜æœ‰æ›´å¤šæ•°æ®
    const hasMore = endIndex < mockCoatings.length;
    
    return {
      success: true,
      data: paginatedData,
      hasMore
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || 'è·å–äº§å“åˆ—è¡¨å¤±è´¥',
      data: []
    };
  }
};

/**
 * è·å–é˜²æ°´æ¶‚æ–™äº§å“è¯¦æƒ…
 * @param id äº§å“ID
 * @returns äº§å“è¯¦æƒ…å“åº”
 */
export const getCoatingDetail = async (id: number): Promise<CoatingDetailResponse> => {
  try {
    // æ¨¡æ‹ŸAPIè°ƒç”¨å»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // æŸ¥æ‰¾äº§å“
    const product = mockCoatings.find(item => item.id === id);
    
    if (product) {
      return {
        success: true,
        data: product
      };
    } else {
      throw new Error('äº§å“ä¸å­˜åœ¨');
    }
  } catch (error: any) {
    return {
      success: false,
      error: error.message || 'è·å–äº§å“è¯¦æƒ…å¤±è´¥'
    };
  }
};

// å¯¼å‡ºå¸¸é‡
export { PAGE_SIZE } from './data';

// å¯¼å‡ºç±»å‹
export * from './types';
===== End of File: api\product\coatingApi.ts =====


===== File: api\product\types.ts =====
// é˜²æ°´æ¶‚æ–™äº§å“ç±»å‹å®šä¹‰

// é˜²æ°´æ¶‚æ–™äº§å“ç±»å‹
export interface WaterproofCoating {
  id: number;
  title: string;             // äº§å“åç§°
  type: string;              // äº§å“è§„æ ¼
  specifications: string;    // å…¨å›½ç»Ÿä¸€é›¶å”®ä»·
  description: string;       // äº§å“ç®€ä»‹
  content: string;           // é€‚ç”¨èŒƒå›´
  images: string[];          // äº§å“å›¾ç‰‡åˆ—è¡¨
}

// åˆ†é¡µæŸ¥è¯¢å‚æ•°
export interface CoatingQueryParams {
  page: number;
  pageSize: number;
}

// APIå“åº”åŸºç¡€æ¥å£
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

// äº§å“åˆ—è¡¨APIå“åº”
export interface CoatingListResponse extends ApiResponse<WaterproofCoating[]> {
  hasMore?: boolean; // æ˜¯å¦è¿˜æœ‰æ›´å¤šæ•°æ®
}

// äº§å“è¯¦æƒ…APIå“åº”
export interface CoatingDetailResponse extends ApiResponse<WaterproofCoating> {}
===== End of File: api\product\types.ts =====


===== File: http\cache.ts =====
import Taro from '@tarojs/taro';
import type { CacheData } from './types';

// ç¼“å­˜é”®å‰ç¼€
const CACHE_PREFIX = 'http_cache_';

/**
 * ç”Ÿæˆç¼“å­˜é”®
 */
export function generateCacheKey(url: string, data?: any): string {
  return `${CACHE_PREFIX}${url}_${JSON.stringify(data || {})}`;
}

/**
 * è·å–ç¼“å­˜æ•°æ®
 */
export function getCacheData<T>(key: string): CacheData<T> | null {
  try {
    const cacheData = Taro.getStorageSync(key);
    return cacheData ? JSON.parse(cacheData) : null;
  } catch (error) {
    console.error('è·å–ç¼“å­˜æ•°æ®å¤±è´¥', error);
    return null;
  }
}

/**
 * è®¾ç½®ç¼“å­˜æ•°æ®
 */
export function setCacheData<T>(key: string, data: T): void {
    try {
      const cacheData: CacheData<T> = {
        data,
        timestamp: Date.now()
      };
      
      Taro.setStorageSync(key, JSON.stringify(cacheData));
    } catch (error) {
      console.error('è®¾ç½®ç¼“å­˜æ•°æ®å¤±è´¥', error);
    }
  }

/**
 * æ¸…é™¤ç¼“å­˜æ•°æ®
 */
export function clearCacheData(key: string): void {
  try {
    Taro.removeStorageSync(key);
  } catch (error) {
    console.error('æ¸…é™¤ç¼“å­˜æ•°æ®å¤±è´¥', error);
  }
}

/**
 * æ¸…é™¤æ‰€æœ‰HTTPç¼“å­˜
 */
export function clearAllCache(): void {
  try {
    const storageInfo = Taro.getStorageInfoSync();
    const keys = storageInfo.keys || [];
    
    keys.forEach(key => {
      if (key.startsWith(CACHE_PREFIX)) {
        Taro.removeStorageSync(key);
      }
    });
  } catch (error) {
    console.error('æ¸…é™¤æ‰€æœ‰ç¼“å­˜å¤±è´¥', error);
  }
}

/**
 * æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ
 */
export function isCacheValid<T>(cache: CacheData<T>, cacheTime: number): boolean {
  if (!cache || !cache.timestamp) return false;
  
  return Date.now() - cache.timestamp < cacheTime;
}
===== End of File: http\cache.ts =====


===== File: http\config.ts =====
import type { RequestConfig } from './types';

// APIåŸºç¡€URL
export const API_BASE_URL = {
  // å¼€å‘ç¯å¢ƒ
  development: 'https://dev-api.example.com/v1',
  // ç”Ÿäº§ç¯å¢ƒ
  production: 'https://api.example.com/v1'
};

// ç¯å¢ƒåˆ¤æ–­
export const ENV = process.env.NODE_ENV || 'development';

// HTTPçŠ¶æ€ç 
export const HTTP_STATUS = {
  SUCCESS: 200,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  SERVER_ERROR: 500
};

// ä¸šåŠ¡çŠ¶æ€ç 
export const BUSINESS_CODE = {
  SUCCESS: 0,           // æˆåŠŸ
  TOKEN_EXPIRED: 10001, // tokenè¿‡æœŸ
  PARAM_ERROR: 10002,   // å‚æ•°é”™è¯¯
  SERVER_ERROR: 50000   // æœåŠ¡å™¨é”™è¯¯
};

// é»˜è®¤è¯·æ±‚é…ç½®
export const DEFAULT_CONFIG: RequestConfig = {
  baseURL: API_BASE_URL[ENV],
  showLoading: true,
  loadingText: 'åŠ è½½ä¸­',
  showErrorToast: true,
  headers: {
    'Content-Type': 'application/json'
  },
  timeout: 10000,       // 10ç§’
  useCache: false,
  cacheTime: 5 * 60 * 1000,  // 5åˆ†é’Ÿ
  retry: 0,
  retryDelay: 1000,
  withToken: true
};
===== End of File: http\config.ts =====


===== File: http\errorHandler.ts =====
import Taro from '@tarojs/taro';
import { HTTP_STATUS, BUSINESS_CODE } from './config';
import type { RequestError, RequestOptions } from './types';

/**
 * å¤„ç†HTTPçŠ¶æ€é”™è¯¯
 */
export function handleHttpError(statusCode: number): RequestError {
  let message = 'æœªçŸ¥é”™è¯¯';
  
  switch (statusCode) {
    case HTTP_STATUS.BAD_REQUEST:
      message = 'è¯·æ±‚å‚æ•°é”™è¯¯';
      break;
    case HTTP_STATUS.UNAUTHORIZED:
      message = 'æœªæˆæƒï¼Œè¯·ç™»å½•';
      break;
    case HTTP_STATUS.FORBIDDEN:
      message = 'æ²¡æœ‰æƒé™è®¿é—®';
      break;
    case HTTP_STATUS.NOT_FOUND:
      message = 'è¯·æ±‚èµ„æºä¸å­˜åœ¨';
      break;
    case HTTP_STATUS.SERVER_ERROR:
      message = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯';
      break;
    default:
      message = `HTTPé”™è¯¯ (${statusCode})`;
  }
  
  return {
    code: statusCode,
    message
  };
}

/**
 * å¤„ç†ä¸šåŠ¡çŠ¶æ€é”™è¯¯
 */
export function handleBusinessError<T>(response: { code: number; message: string; data?: T }): RequestError {
  let message = response.message || 'æœªçŸ¥é”™è¯¯';
  
  switch (response.code) {
    case BUSINESS_CODE.TOKEN_EXPIRED:
      message = 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•';
      break;
    case BUSINESS_CODE.PARAM_ERROR:
      message = 'å‚æ•°é”™è¯¯';
      break;
    case BUSINESS_CODE.SERVER_ERROR:
      message = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯';
      break;
  }
  
  return {
    code: response.code,
    message,
    data: response.data
  };
}

/**
 * å¤„ç†ç½‘ç»œé”™è¯¯
 */
export function handleNetworkError(error: any): RequestError {
  let message = 'ç½‘ç»œå¼‚å¸¸';
  
  if (error?.errMsg) {
    if (error.errMsg.includes('timeout')) {
      message = 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ';
    } else if (error.errMsg.includes('fail')) {
      message = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®';
    }
  }
  
  return {
    code: -1,
    message
  };
}

/**
 * ç»¼åˆé”™è¯¯å¤„ç†
 */
export function handleRequestError(error: any, options: RequestOptions): RequestError {
  // å·²æ ¼å¼åŒ–çš„é”™è¯¯
  if (error && typeof error === 'object' && 'code' in error && 'message' in error) {
    if (options.showErrorToast) {
      Taro.showToast({
        title: error.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return error as RequestError;
  }
  
  // HTTPé”™è¯¯
  if (error && typeof error === 'object' && 'statusCode' in error) {
    const httpError = handleHttpError(error.statusCode);
    
    if (options.showErrorToast) {
      Taro.showToast({
        title: httpError.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return httpError;
  }
  
  // ç½‘ç»œé”™è¯¯
  if (error && typeof error === 'object' && 'errMsg' in error) {
    const networkError = handleNetworkError(error);
    
    if (options.showErrorToast) {
      Taro.showToast({
        title: networkError.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return networkError;
  }
  
  // å…¶ä»–é”™è¯¯
  const unknownError: RequestError = {
    code: -1,
    message: typeof error === 'string' ? error : 'æœªçŸ¥é”™è¯¯'
  };
  
  if (options.showErrorToast) {
    Taro.showToast({
      title: unknownError.message,
      icon: 'none',
      duration: 2000
    });
  }
  
  return unknownError;
}
===== End of File: http\errorHandler.ts =====


===== File: http\index.ts =====
import { request } from './request';
import type { RequestOptions} from './types';
import { addRequestInterceptor, addResponseInterceptor, addErrorInterceptor } from './interceptor';
import { clearAllCache, clearCacheData } from './cache';

/**
 * HTTPå®¢æˆ·ç«¯
 */
const http = {
  /**
   * å‘é€GETè¯·æ±‚
   */
  get: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'GET', data, ...options }),
  
  /**
   * å‘é€POSTè¯·æ±‚
   */  
  post: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'POST', data, ...options }),
  
  /**
   * å‘é€PUTè¯·æ±‚
   */
  put: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'PUT', data, ...options }),
  
  /**
   * å‘é€DELETEè¯·æ±‚
   */
  delete: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'DELETE', data, ...options }),
  
  /**
   * åŸå§‹è¯·æ±‚æ–¹æ³•
   */
  request,
  
  /**
   * æ¸…é™¤æŒ‡å®šç¼“å­˜
   */
  clearCache: clearCacheData,
  
  /**
   * æ¸…é™¤æ‰€æœ‰ç¼“å­˜
   */
  clearAllCache,
  
  /**
   * æ·»åŠ è¯·æ±‚æ‹¦æˆªå™¨
   */
  addRequestInterceptor,
  
  /**
   * æ·»åŠ å“åº”æ‹¦æˆªå™¨
   */
  addResponseInterceptor,
  
  /**
   * æ·»åŠ é”™è¯¯æ‹¦æˆªå™¨
   */
  addErrorInterceptor
};

export default http;

// å¯¼å‡ºç±»å‹
export * from './types';
export { DEFAULT_CONFIG } from './config';
===== End of File: http\index.ts =====


===== File: http\interceptor.ts =====
import Taro from '@tarojs/taro';
import type { RequestInterceptor, ResponseInterceptor, ErrorInterceptor, RequestOptions, ResponseData } from './types';
import { BUSINESS_CODE } from './config';

// è¯·æ±‚æ‹¦æˆªå™¨æ•°ç»„
const requestInterceptors: RequestInterceptor[] = [];

// å“åº”æ‹¦æˆªå™¨æ•°ç»„
const responseInterceptors: ResponseInterceptor[] = [];

// é”™è¯¯æ‹¦æˆªå™¨æ•°ç»„
const errorInterceptors: ErrorInterceptor[] = [];

/**
 * æ·»åŠ è¯·æ±‚æ‹¦æˆªå™¨
 */
export function addRequestInterceptor(interceptor: RequestInterceptor): void {
  requestInterceptors.push(interceptor);
}

/**
 * æ·»åŠ å“åº”æ‹¦æˆªå™¨
 */
export function addResponseInterceptor(interceptor: ResponseInterceptor): void {
  responseInterceptors.push(interceptor);
}

/**
 * æ·»åŠ é”™è¯¯æ‹¦æˆªå™¨
 */
export function addErrorInterceptor(interceptor: ErrorInterceptor): void {
  errorInterceptors.push(interceptor);
}

/**
 * åº”ç”¨è¯·æ±‚æ‹¦æˆªå™¨
 */
export async function applyRequestInterceptors(options: RequestOptions): Promise<RequestOptions> {
  let config = { ...options };
  
  for (const interceptor of requestInterceptors) {
    config = await interceptor(config);
  }
  
  return config;
}

/**
 * åº”ç”¨å“åº”æ‹¦æˆªå™¨
 */
export async function applyResponseInterceptors<T>(response: ResponseData<T>, options: RequestOptions): Promise<ResponseData<T>> {
  let result = { ...response };
  
  for (const interceptor of responseInterceptors) {
    result = await interceptor(result, options);
  }
  
  return result;
}

/**
 * åº”ç”¨é”™è¯¯æ‹¦æˆªå™¨
 */
export async function applyErrorInterceptors(error: any, options: RequestOptions): Promise<any> {
  let result = error;
  
  for (const interceptor of errorInterceptors) {
    result = await interceptor(result, options);
  }
  
  return result;
}

// æ·»åŠ é»˜è®¤Tokenæ‹¦æˆªå™¨
addRequestInterceptor(async (options) => {
  if (options.withToken) {
    try {
      const token = Taro.getStorageSync('token');
      if (token) {
        options.headers = {
          ...options.headers,
          'Authorization': `Bearer ${token}`
        };
      }
    } catch (error) {
      console.error('è·å–Tokenå¤±è´¥', error);
    }
  }
  
  return options;
});

// æ·»åŠ é»˜è®¤æ—¥å¿—æ‹¦æˆªå™¨
if (process.env.NODE_ENV === 'development') {
  // è¯·æ±‚æ—¥å¿—
  addRequestInterceptor((options) => {
    console.log(`[Request] ${options.method} ${options.url}`, options.data);
    return options;
  });
  
  // å“åº”æ—¥å¿—
  addResponseInterceptor((response, options) => {
    console.log(`[Response] ${options.method} ${options.url}`, response);
    return response;
  });
  
  // é”™è¯¯æ—¥å¿—
  addErrorInterceptor((error, options) => {
    console.error(`[Error] ${options.method} ${options.url}`, error);
    return error;
  });
}

// æ·»åŠ é»˜è®¤Tokenè¿‡æœŸå¤„ç†
addErrorInterceptor((error) => {
  if (error && error.code === BUSINESS_CODE.TOKEN_EXPIRED) {
    // æ¸…é™¤æœ¬åœ°Token
    Taro.removeStorageSync('token');
    
    // è·³è½¬åˆ°ç™»å½•é¡µ
    Taro.navigateTo({
      url: '/pages/login/index'
    });
  }
  
  return error;
});
===== End of File: http\interceptor.ts =====


===== File: http\request.ts =====
import Taro from '@tarojs/taro';
import type { RequestOptions, ResponseData } from './types';
import { DEFAULT_CONFIG, BUSINESS_CODE } from './config';
import { applyRequestInterceptors, applyResponseInterceptors, applyErrorInterceptors } from './interceptor';
import { handleRequestError, handleBusinessError } from './errorHandler';
import { generateCacheKey, getCacheData, setCacheData, isCacheValid } from './cache';

// è¯·æ±‚è®¡æ•°å™¨
let loadingCount = 0;

/**
 * æ˜¾ç¤ºåŠ è½½æç¤º
 */
function showLoading(text: string): void {
  loadingCount++;
  
  if (loadingCount === 1) {
    Taro.showLoading({ title: text });
  }
}

/**
 * éšè—åŠ è½½æç¤º
 */
function hideLoading(): void {
  loadingCount--;
  
  if (loadingCount === 0) {
    Taro.hideLoading();
  }
}

/**
 * å»¶è¿Ÿå‡½æ•°
 */
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * ç»Ÿä¸€è¯·æ±‚å‡½æ•°
 */
export async function request<T = any>(options: RequestOptions): Promise<T> {
  // åˆå¹¶é…ç½®
  const config = { ...DEFAULT_CONFIG, ...options };
  const { url, method = 'GET', data, baseURL, showLoading: shouldShowLoading, loadingText, useCache, cacheTime, retry, retryDelay } = config;
  
  // å®Œæ•´URL
  const fullUrl = url.startsWith('http') ? url : `${baseURL}${url.startsWith('/') ? url : `/${url}`}`;
  
  // æ£€æŸ¥ç¼“å­˜
  if (useCache && method === 'GET') {
    const cacheKey = generateCacheKey(fullUrl, data);
    const cached = getCacheData<T>(cacheKey);
    
    if (cached && isCacheValid(cached, cacheTime || DEFAULT_CONFIG.cacheTime || 0)) {
      return cached.data;
    }
  }
  
  // è¯·æ±‚å‰å¤„ç†
  let requestConfig = await applyRequestInterceptors({ ...config, url: fullUrl });
  
  // é‡è¯•è®¡æ•°
  let retryCount = retry || 0;
  
  // æ˜¾ç¤ºåŠ è½½æç¤º
  if (shouldShowLoading) {
    showLoading(loadingText || 'åŠ è½½ä¸­');
  }
  
  try {
    // å‘é€è¯·æ±‚
    const executeRequest = async (): Promise<T> => {
      try {
        const response = await Taro.request({
          url: fullUrl,
          data: requestConfig.data,
          method: requestConfig.method as any,
          header: requestConfig.headers,
          timeout: requestConfig.timeout
        });
        
        // HTTPçŠ¶æ€æ£€æŸ¥
        if (response.statusCode !== 200) {
          throw { statusCode: response.statusCode };
        }
        
        // ä¸šåŠ¡çŠ¶æ€æ£€æŸ¥
        const responseData = response.data as ResponseData<T>;
        
        if (responseData.code !== BUSINESS_CODE.SUCCESS) {
          throw handleBusinessError(responseData);
        }
        
        // å“åº”æ‹¦æˆªå¤„ç†
        const processedResponse = await applyResponseInterceptors(responseData, requestConfig);
        
        // è®¾ç½®ç¼“å­˜
        if (useCache && method === 'GET') {
          const cacheKey = generateCacheKey(fullUrl, data);
          setCacheData(cacheKey, processedResponse.data);
        }
        
        return processedResponse.data;
      } catch (error) {
        // è¯·æ±‚å¤±è´¥ä½†è¿˜æœ‰é‡è¯•æ¬¡æ•°
        if (retryCount > 0) {
          retryCount--;
          // å»¶è¿Ÿåé‡è¯•
          await delay(retryDelay || DEFAULT_CONFIG.retryDelay || 1000);
          return executeRequest();
        }
        
        // é‡è¯•æ¬¡æ•°ç”¨å®Œï¼Œå‘ä¸ŠæŠ›å‡ºé”™è¯¯
        throw error;
      }
    };
    
    return await executeRequest();
  } catch (error) {
    // é”™è¯¯å¤„ç†
    const processedError = await applyErrorInterceptors(error, requestConfig);
    throw handleRequestError(processedError, requestConfig);
  } finally {
    // éšè—åŠ è½½æç¤º
    if (shouldShowLoading) {
      hideLoading();
    }
  }
}
===== End of File: http\request.ts =====


===== File: http\types.ts =====
// è¯·æ±‚æ–¹æ³•ç±»å‹
export type RequestMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

// è¯·æ±‚é…ç½®
export interface RequestConfig {
  // åŸºç¡€URL
  baseURL?: string;
  // æ˜¯å¦æ˜¾ç¤ºåŠ è½½æç¤º
  showLoading?: boolean;
  // åŠ è½½æç¤ºæ–‡å­—
  loadingText?: string;
  // æ˜¯å¦æ˜¾ç¤ºé”™è¯¯æç¤º
  showErrorToast?: boolean;
  // è¯·æ±‚å¤´
  headers?: Record<string, string>;
  // è¶…æ—¶æ—¶é—´(ms)
  timeout?: number;
  // æ˜¯å¦ä½¿ç”¨ç¼“å­˜(ä»…GETè¯·æ±‚)
  useCache?: boolean;
  // ç¼“å­˜æ—¶é—´(ms)
  cacheTime?: number;
  // é‡è¯•æ¬¡æ•°
  retry?: number;
  // é‡è¯•å»¶è¿Ÿ(ms)
  retryDelay?: number;
  // æ˜¯å¦è‡ªåŠ¨æºå¸¦token
  withToken?: boolean;
}

// è¯·æ±‚å‚æ•°
export interface RequestOptions extends RequestConfig {
  // è¯·æ±‚åœ°å€
  url: string;
  // è¯·æ±‚æ–¹æ³•
  method?: RequestMethod;
  // è¯·æ±‚æ•°æ®
  data?: any;
}

// å“åº”æ•°æ®ç»“æ„
export interface ResponseData<T = any> {
  code: number;
  message: string;
  data: T;
}

// ç¼“å­˜æ•°æ®ç»“æ„
export interface CacheData<T = any> {
  data: T;
  timestamp: number;
}

// é”™è¯¯ä¿¡æ¯ç»“æ„
export interface RequestError {
  code: number;
  message: string;
  data?: any;
}

// è¯·æ±‚æ‹¦æˆªå™¨
export type RequestInterceptor = (options: RequestOptions) => RequestOptions | Promise<RequestOptions>;

// å“åº”æ‹¦æˆªå™¨
export type ResponseInterceptor = <T>(response: ResponseData<T>, options: RequestOptions) => ResponseData<T> | Promise<ResponseData<T>>;

// é”™è¯¯æ‹¦æˆªå™¨
export type ErrorInterceptor = (error: any, options: RequestOptions) => any;
===== End of File: http\types.ts =====

