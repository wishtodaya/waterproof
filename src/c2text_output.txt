ğŸ“ src
  ğŸ“„ app.config.ts
  ğŸ“„ app.scss
  ğŸ“„ app.ts
  ğŸ“ components
    ğŸ“ BookingForm
      ğŸ“„ index.scss
      ğŸ“„ index.tsx
    ğŸ“ ContactInfoCard
      ğŸ“„ index.scss
      ğŸ“„ index.tsx
    ğŸ“ QuickContact
      ğŸ“„ index.scss
      ğŸ“„ index.tsx
  ğŸ“„ index.html
  ğŸ“ packageA
    ğŸ“ pages
  ğŸ“ pages
    ğŸ“ contact
      ğŸ“„ index.config.ts
      ğŸ“„ index.scss
      ğŸ“„ index.tsx
  ğŸ“ services
    ğŸ“ api
      ğŸ“ contact
        ğŸ“„ contactApi.ts
        ğŸ“„ data.ts
        ğŸ“„ types.ts
    ğŸ“ http
      ğŸ“„ cache.ts
      ğŸ“„ config.ts
      ğŸ“„ errorHandler.ts
      ğŸ“„ index.ts
      ğŸ“„ interceptor.ts
      ğŸ“„ request.ts
      ğŸ“„ types.ts
  ğŸ“ styles
    ğŸ“„ theme.css

===== File: app.config.ts =====
export default defineAppConfig({
  // å°†æ‰€æœ‰TabBaré¡µé¢æ”¾åœ¨ä¸»åŒ…ä¸­
  pages: [
    'pages/index/index',
    'pages/product/index',
    'pages/cases/index',
    'pages/contact/index'
  ],
  window: {
    backgroundTextStyle: 'light',
    navigationBarBackgroundColor: '#FFFFFF',
    navigationBarTitleText: 'éƒ‘å¼ä¿®ç¼®', // ä¿®æ”¹å¯¼èˆªæ ‡é¢˜
    navigationBarTextStyle: 'black'
  },
  // éTabBaré¡µé¢å¯ä»¥æ”¾åœ¨åˆ†åŒ…ä¸­
  subPackages: [],
  tabBar: {
    color: '#757575',
    selectedColor: '#2563EB',
    backgroundColor: '#FFFFFF',
    borderStyle: 'white',
    list: [
      {
        pagePath: 'pages/index/index',
        text: 'é¦–é¡µ',
        iconPath: 'assets/tab-bar/home.png',
        selectedIconPath: 'assets/tab-bar/home-active.png'
      },
      {
        pagePath: 'pages/product/index',
        text: 'äº§å“',
        iconPath: 'assets/tab-bar/service.png',
        selectedIconPath: 'assets/tab-bar/service-active.png'
      },
      {
        pagePath: 'pages/cases/index',
        text: 'æ¡ˆä¾‹',
        iconPath: 'assets/tab-bar/case.png',
        selectedIconPath: 'assets/tab-bar/case-active.png'
      },
      {
        pagePath: 'pages/contact/index',
        text: 'è”ç³»æˆ‘ä»¬',
        iconPath: 'assets/tab-bar/contact.png',
        selectedIconPath: 'assets/tab-bar/contact-active.png'
      }
    ]
  },
  lazyCodeLoading: "requiredComponents"
})
===== End of File: app.config.ts =====


===== File: app.scss =====
/* app.scss - é€‚ç”¨äº Taro + NutUI React å¤šç«¯é¡¹ç›® */

/* å…¨å±€åŸºç¡€æ ·å¼ */
page {
    height: 100%;
    font-size: 16px;
    line-height: 1.5;
    color: var(--nutui-gray-7);
    background-color: var(--nutui-gray-3);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  }
  
  /* å®¹å™¨å¸ƒå±€ */
  .container {
    padding: 10px;
  }
  
  /* å¼¹æ€§å¸ƒå±€å·¥å…· */
  .flex {
    display: flex;
    
    &-center {
      align-items: center;
      justify-content: center;
    }
    
    &-between {
      align-items: center;
      justify-content: space-between;
    }
    
    &-column {
      flex-direction: column;
    }
  }
  
  /* é—´è·è¾…åŠ©ç±» - ç²¾ç®€ç‰ˆ */
  .mt-10 { margin-top: 10px; }
  .mr-10 { margin-right: 10px; }
  .mb-10 { margin-bottom: 10px; }
  .ml-10 { margin-left: 10px; }
  .pt-10 { padding-top: 10px; }
  .pr-10 { padding-right: 10px; }
  .pb-10 { padding-bottom: 10px; }
  .pl-10 { padding-left: 10px; }
  
  /* å¸¸ç”¨æ–‡æœ¬æ ·å¼ */
  .text-primary { color: var(--nutui-color-primary); }
  .text-center { text-align: center; }
  .text-bold { font-weight: bold; }
  
  /* å¡ç‰‡ç»„ä»¶ */
  .card {
    background-color: #fff;
    border-radius: 8px;
    padding: 15px;
    margin-bottom: 15px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }
  
  /* 1px è¾¹æ¡†è§£å†³æ–¹æ¡ˆ */
  .hairline-bottom {
    position: relative;
    
    &::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 1px;
      background-color: var(--nutui-gray-4);
      transform: scaleY(0.5);
    }
  }
  
  /* å®‰å…¨åŒºé€‚é… */
  .safe-bottom {
    padding-bottom: constant(safe-area-inset-bottom);
    padding-bottom: env(safe-area-inset-bottom);
  }
===== End of File: app.scss =====


===== File: app.ts =====
import  { useEffect } from 'react'
import { useDidShow, useDidHide } from '@tarojs/taro'

// å…¨å±€æ ·å¼
import './styles/theme.css'
import './app.scss'

function App(props) {
  // å¯ä»¥ä½¿ç”¨æ‰€æœ‰çš„ React Hooks
  useEffect(() => {})

  // å¯¹åº” onShow
  useDidShow(() => {})

  // å¯¹åº” onHide
  useDidHide(() => {})

  return props.children
}

export default App
===== End of File: app.ts =====


===== File: components\BookingForm\index.scss =====
/* é¢„çº¦è¡¨å•æ ·å¼ */
.booking-form {
  position: relative;
  padding: 0 4px;
  
  /* ===== åŸºç¡€è¡¨å•é¡¹æ ·å¼ ===== */
  .form-item {
    margin-bottom: 20px;
  }
  
  /* è¡¨å•æ ‡ç­¾ */
  .form-item-label {
    display: block;
    font-size: 14px;
    font-weight: 500;
    color: #1e293b;
    margin-bottom: 8px;
    
    /* å¿…å¡«é¡¹æ ‡è®° */
    &.required::before {
      content: '*';
      color: #ef4444;
      font-size: 16px;
      margin-right: 4px;
    }
  }
  
  /* é”™è¯¯æç¤º */
  .form-error-tip {
    font-size: 12px;
    color: #ef4444;
    margin-top: 4px;
    padding-left: 16px;
    position: relative;
    
    &::before {
      content: "!";
      position: absolute;
      left: 0;
      top: 0;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(239, 68, 68, 0.1);
      color: #ef4444;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
    }
  }
  
  /* ===== è¡¨å•æ§ä»¶é€šç”¨æ ·å¼ ===== */
  .form-input,
  .form-select,
  .form-textarea {
    width: 100%;
    background: #ffffff;
    border: 1px solid #dce0e4;
    border-radius: 8px;
    font-size: 14px;
    color: #1e293b;
    box-sizing: border-box;
    margin-top: 8px;
    transition: border-color 0.2s ease;
    
    &:focus, 
    &:active {
      border-color: #3b82f6;
      outline: none;
    }
    
    &::placeholder {
      color: #9ca3af;
    }
  }
  
  /* è¾“å…¥æ¡† */
  .form-input {
    display: block;
    height: 44px;
    padding: 0 14px;
  }
  
  /* é€‰æ‹©å™¨ */
  .form-select {
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 44px;
    padding: 0 14px;
    position: relative;
    
    .select-placeholder {
      color: #9ca3af;
    }
    
    .select-value {
      color: #1e293b;
    }
    
    /* ç®­å¤´å›¾æ ‡ */
    .select-arrow {
      width: 8px;
      height: 8px;
      border-top: 2px solid #94a3b8;
      border-right: 2px solid #94a3b8;
      transform: rotate(45deg);
      margin-left: 4px;
      flex-shrink: 0;
    }
  }
  
  /* æ–‡æœ¬åŸŸ */
  .form-textarea {
    display: block;
    min-height: 100px;
    padding: 12px 14px;
    resize: none;
  }
  
  /* ===== æäº¤æŒ‰é’® ===== */
  .submit-container {
    margin-top: 24px;
    margin-bottom: 10px;
    width: 100%;
  }
  
  .submit-button {
    display: block;
    width: 100%;
    height: 46px;
    font-size: 16px;
    font-weight: 500;
    color: #ffffff;
    background: #2563EB;
    border-radius: 8px;
    border: none;
    outline: none;
    cursor: pointer;
    transition: opacity 0.2s ease;
    
    &:active {
      opacity: 0.9;
    }
    
    &.loading {
      opacity: 0.8;
    }
  }
}
===== End of File: components\BookingForm\index.scss =====


===== File: components\BookingForm\index.tsx =====
import { useState} from 'react'
import { View, Text, Picker as TaroPicker, Input, Textarea, Button } from '@tarojs/components'
import Taro from '@tarojs/taro'
import { Toast, Picker } from '@nutui/nutui-react-taro'
import './index.scss'

export interface BookingFormData {
  name: string;
  phone: string;
  serviceType: string;
  serviceTypeName: string;
  region: string[];
  address: string;
  remark: string;
}

interface BookingFormProps {
  serviceTypes: { text: string; value: string }[];
  loading: boolean;
  initialValues?: Partial<BookingFormData>;
  onSubmit: (data: BookingFormData) => void;
  onServiceTypeSelect: (type: string) => void;
}

const BookingForm: React.FC<BookingFormProps> = ({ 
  serviceTypes, 
  loading,
  initialValues = {},
  onSubmit, 
  onServiceTypeSelect
}) => {
  // è¡¨å•çŠ¶æ€
  const [formData, setFormData] = useState<Partial<BookingFormData>>(initialValues);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [showToast, setShowToast] = useState(false);
  const [toastInfo, setToastInfo] = useState({ content: '', icon: 'success' });
  
  // PickerçŠ¶æ€
  const [showServicePicker, setShowServicePicker] = useState(false);
  
  // ç›´æ¥ä½¿ç”¨serviceTypesï¼Œä¸åšæ˜ å°„è½¬æ¢
  const pickerServiceOptions = [serviceTypes];
  
  // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
  const showMessage = (content, icon = 'success') => {
    setToastInfo({ content, icon });
    setShowToast(true);
  };
  
  // æ›´æ–°è¡¨å•å­—æ®µ
  const updateField = (field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }));
    
    // æ¸…é™¤é”™è¯¯
    if (errors[field]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[field];
        return newErrors;
      });
    }
  };
  
  // å¤„ç†æœåŠ¡ç±»å‹ç¡®è®¤
  const handleServiceConfirm = (selectedOptions) => {
    if (selectedOptions && selectedOptions[0]) {
      updateField('serviceType', selectedOptions[0].value);
      updateField('serviceTypeName', selectedOptions[0].text);
      onServiceTypeSelect(selectedOptions[0].value);
      
      // æ·»åŠ éœ‡åŠ¨åé¦ˆ
      Taro.vibrateShort();
    }
  };
  
  // å¤„ç†åœ°åŒºé€‰æ‹©
  const handleRegionChange = (e) => {
    updateField('region', e.detail.value);
  };
  
  // è¡¨å•éªŒè¯
  const validateForm = () => {
    const newErrors: Record<string, string> = {};
    
    // éªŒè¯å§“å
    if (!formData.name || formData.name.trim().length < 2) {
      newErrors.name = 'è¯·è¾“å…¥è”ç³»äººå§“å(è‡³å°‘2ä¸ªå­—ç¬¦)';
    }
    
    // éªŒè¯æ‰‹æœºå·
    if (!formData.phone || !/^1[3-9]\d{9}$/.test(formData.phone)) {
      newErrors.phone = 'è¯·è¾“å…¥æ­£ç¡®çš„æ‰‹æœºå·';
    }
    
    // éªŒè¯æœåŠ¡ç±»å‹
    if (!formData.serviceType) {
      newErrors.serviceType = 'è¯·é€‰æ‹©æœåŠ¡ç±»å‹';
    }
    
    // éªŒè¯æ‰€åœ¨åœ°åŒº
    if (!formData.region || !formData.region.length) {
      newErrors.region = 'è¯·é€‰æ‹©æ‰€åœ¨åœ°åŒº';
    }
    
    // éªŒè¯è¯¦ç»†åœ°å€
    if (!formData.address || formData.address.trim().length < 5) {
      newErrors.address = 'è¯·è¾“å…¥è¯¦ç»†åœ°å€(è‡³å°‘5ä¸ªå­—ç¬¦)';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  // æäº¤è¡¨å•
  const handleSubmit = () => {
    if (validateForm()) {
      // æ·»åŠ éœ‡åŠ¨åé¦ˆ
      Taro.vibrateShort();
      onSubmit(formData as BookingFormData);
    } else {
      // æäº¤å¤±è´¥éœ‡åŠ¨
      Taro.vibrateShort();
      showMessage('è¯·å®Œå–„å¿…å¡«ä¿¡æ¯', 'fail');
    }
  };
  
  // æ ¹æ®è¡¨å•å€¼è·å–æ˜¾ç¤ºæ–‡æœ¬
  const getServiceTypeText = () => {
    if (formData.serviceType) {
      const selectedType = serviceTypes.find(item => item.value === formData.serviceType);
      return selectedType?.text || 'è¯·é€‰æ‹©æœåŠ¡ç±»å‹';
    }
    return 'è¯·é€‰æ‹©æœåŠ¡ç±»å‹';
  };
  
  const getRegionText = () => {
    if (formData.region && formData.region.length > 0) {
      return formData.region.join(' ');
    }
    return 'è¯·é€‰æ‹©æ‰€åœ¨åœ°åŒº';
  };
  
  return (
    <View className="booking-form">
      {/* è”ç³»äººå§“å */}
      <View className="form-item">
        <Text className="form-item-label required">è”ç³»äººå§“å</Text>
        <Input 
          className="form-input"
          placeholder="è¯·è¾“å…¥å§“å"
          value={formData.name}
          onInput={e => updateField('name', e.detail.value)}
        />
        {errors.name && <Text className="form-error-tip">{errors.name}</Text>}
      </View>
      
      {/* è”ç³»ç”µè¯ */}
      <View className="form-item">
        <Text className="form-item-label required">è”ç³»ç”µè¯</Text>
        <Input
          className="form-input"
          placeholder="è¯·è¾“å…¥æ‰‹æœºå·ç "
          type="number"
          value={formData.phone}
          onInput={e => updateField('phone', e.detail.value)}
        />
        {errors.phone && <Text className="form-error-tip">{errors.phone}</Text>}
      </View>
      
      {/* æœåŠ¡ç±»å‹ */}
      <View className="form-item">
        <Text className="form-item-label required">æœåŠ¡ç±»å‹</Text>
        <View 
          className="form-select"
          onClick={() => setShowServicePicker(true)}
        >
          <Text className={formData.serviceType ? 'select-value' : 'select-placeholder'}>
            {getServiceTypeText()}
          </Text>
          <View className="select-arrow" />
        </View>
        {errors.serviceType && <Text className="form-error-tip">{errors.serviceType}</Text>}
      </View>
      
      {/* æ‰€åœ¨åœ°åŒº */}
      <View className="form-item">
        <Text className="form-item-label required">æ‰€åœ¨åœ°åŒº</Text>
        <TaroPicker
          mode="region"
          onChange={handleRegionChange}
        >
          <View className="form-select">
            <Text className={formData.region?.length ? 'select-value' : 'select-placeholder'}>
              {getRegionText()}
            </Text>
            <View className="select-arrow" />
          </View>
        </TaroPicker>
        {errors.region && <Text className="form-error-tip">{errors.region}</Text>}
      </View>
      
      {/* è¯¦ç»†åœ°å€ */}
      <View className="form-item">
        <Text className="form-item-label required">è¯¦ç»†åœ°å€</Text>
        <Input
          className="form-input"
          placeholder="è¯·è¾“å…¥è¯¦ç»†åœ°å€"
          value={formData.address}
          onInput={e => updateField('address', e.detail.value)}
        />
        {errors.address && <Text className="form-error-tip">{errors.address}</Text>}
      </View>
      
      {/* è¡¥å……è¯´æ˜ */}
      <View className="form-item">
        <Text className="form-item-label">è¡¥å……è¯´æ˜</Text>
        <Textarea
          className="form-textarea"
          placeholder="è¯·è¾“å…¥æ‚¨çš„å…·ä½“éœ€æ±‚æˆ–å…¶ä»–è¯´æ˜ï¼ˆé€‰å¡«ï¼‰"
          maxlength={200}
          value={formData.remark}
          onInput={e => updateField('remark', e.detail.value)}
        />
      </View>
      
      {/* æäº¤æŒ‰é’® */}
      <View className="submit-container">
        <Button
          className={`submit-button ${loading ? 'loading' : ''}`}
          onClick={handleSubmit}
          disabled={loading}
        >
          {loading ? 'æäº¤ä¸­...' : 'ç«‹å³é¢„çº¦'}
        </Button>
      </View>
      
      {/* NutUI Picker æœåŠ¡ç±»å‹é€‰æ‹©å™¨ */}
      <Picker
        title="é€‰æ‹©æœåŠ¡ç±»å‹"
        visible={showServicePicker}
        options={pickerServiceOptions}
        defaultValue={formData.serviceType ? [formData.serviceType] : []}
        onClose={() => setShowServicePicker(false)}
        onConfirm={handleServiceConfirm}
      />
      
      {/* æç¤ºä¿¡æ¯ */}
      <Toast
        visible={showToast}
        content={toastInfo.content}
        icon={toastInfo.icon}
        onClose={() => setShowToast(false)}
      />
    </View>
  );
};

export default BookingForm;
===== End of File: components\BookingForm\index.tsx =====


===== File: components\ContactInfoCard\index.scss =====
/* components/ContactInfoCard/index.scss */
.contact-info {
    /* å…³äºæˆ‘ä»¬æè¿°æ ·å¼ */
    .about-description {
      font-size: 14px;
      line-height: 1.6;
      color: #475569;
      margin-bottom: 20px;
      text-align: justify;
      padding: 0 2px;
    }
    
    .info-divider {
      height: 1px;
      background-color: rgba(0, 0, 0, 0.06);
      margin: 10px 0 18px;
    }
    
    .info-cells {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    
    /* è”ç³»ä¿¡æ¯å•å…ƒæ ¼æ ·å¼ */
    .info-cell {
      margin-bottom: 0;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.8);
      transition: all 0.2s;
      overflow: visible; /* ç¡®ä¿å†…å®¹ä¸è¢«æˆªæ–­ */
      
      &:active {
        background: #ffffff;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      }
    }
    
    /* è”ç³»ä¿¡æ¯å†…å®¹å¸ƒå±€ */
    .info-cell-content {
      display: flex;
      align-items: center;
      gap: 14px;
      padding: 14px;
      width: 100%;
      box-sizing: border-box;
    }
    
    /* è”ç³»ä¿¡æ¯å›¾æ ‡åŸºç¡€æ ·å¼ */
    .info-icon {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      flex-shrink: 0;
    }
    
    /* ç”µè¯å›¾æ ‡æ ·å¼ */
    .phone-icon {
      background-color: rgba(14, 165, 233, 0.12);
      
      &::before {
        content: '';
        width: 15px;
        height: 15px;
        border: 2px solid #0ea5e9;
        border-radius: 50%;
        position: absolute;
        left: 11px;
        top: 10px;
      }
      
      &::after {
        content: '';
        width: 6px;
        height: 8px;
        border-bottom: 2px solid #0ea5e9;
        border-left: 2px solid #0ea5e9;
        position: absolute;
        right: 12px;
        bottom: 12px;
        transform: rotate(-45deg);
      }
    }
    
    /* å¾®ä¿¡å›¾æ ‡æ ·å¼ */
    .wechat-icon {
      background-color: rgba(16, 185, 129, 0.12);
      
      &::before {
        content: '';
        width: 20px;
        height: 18px;
        border: 2px solid #10b981;
        border-radius: 4px;
        position: absolute;
      }
    }
    
    /* æ—¶é—´å›¾æ ‡æ ·å¼ */
    .time-icon {
      background-color: rgba(168, 85, 247, 0.12);
      
      &::before {
        content: '';
        width: 18px;
        height: 18px;
        border: 2px solid #a855f7;
        border-radius: 50%;
        position: absolute;
      }
      
      &::after {
        content: '';
        width: 8px;
        height: 8px;
        border-top: 2px solid #a855f7;
        border-right: 2px solid #a855f7;
        position: absolute;
        left: 15px;
        top: 12px;
        transform: rotate(45deg);
      }
    }
    
    /* åœ°å€å›¾æ ‡æ ·å¼ */
    .address-icon {
      background-color: rgba(239, 68, 68, 0.12);
      
      &::before {
        content: '';
        width: 12px;
        height: 12px;
        background-color: #ef4444;
        border-radius: 50%;
        position: absolute;
        top: 10px;
      }
      
      &::after {
        content: '';
        width: 0;
        height: 12px;
        border-left: 2px solid #ef4444;
        position: absolute;
        top: 18px;
      }
    }
    
    /* è”ç³»ä¿¡æ¯æ–‡æœ¬æ ·å¼ */
    .info-text {
      display: flex;
      flex-direction: column;
      flex: 1;
      width: calc(100% - 55px); /* ç¡®ä¿æœ‰è¶³å¤Ÿçš„å®½åº¦ï¼Œå‡å»å›¾æ ‡å®½åº¦å’Œé—´è· */
      overflow: visible; /* ç¡®ä¿ä¸ä¼šè¢«æˆªæ–­ */
    }
    
    .info-label {
      font-size: 12px;
      color: #64748b;
      margin-bottom: 4px;
    }
    
    .info-value {
      font-size: 14px;
      color: #1e293b;
      font-weight: 500;
      word-break: break-all; /* å…è®¸åœ¨ä»»ä½•å­—ç¬¦é—´æ–­è¡Œ */
      white-space: normal; /* å…è®¸æ­£å¸¸æ¢è¡Œ */
      line-height: 1.4;
      overflow: visible; /* ç¡®ä¿ä¸ä¼šè¢«æˆªæ–­ */
      width: 100%; /* åˆ©ç”¨æ‰€æœ‰å¯ç”¨ç©ºé—´ */
    }
    
    /* åœ°å€ç‰¹æ®Šå¤„ç† */
    .info-cell-address {
      .info-cell-content {
        align-items: flex-start; /* æ”¹ä¸ºé¡¶éƒ¨å¯¹é½ */
        padding-bottom: 16px; /* å¢åŠ åº•éƒ¨é—´è· */
      }
      
      .info-icon {
        margin-top: 2px; /* å¾®è°ƒå›¾æ ‡ä½ç½® */
      }
      
      .info-value {
        min-height: 40px; /* ç¡®ä¿æœ‰è¶³å¤Ÿçš„é«˜åº¦ */
        width: 100%; /* ç¡®ä¿æ–‡æœ¬æœ‰è¶³å¤Ÿçš„å®½åº¦ */
        white-space: pre-wrap; /* ä¿ç•™ç©ºæ ¼å¹¶æ¢è¡Œ */
        line-height: 1.5; /* å¢åŠ è¡Œé«˜ä½¿å¤šè¡Œæ–‡æœ¬æ›´æ˜“è¯» */
        padding-right: 4px; /* å³ä¾§ç•™å‡ºç©ºé—´ï¼Œé¿å…æ–‡æœ¬é è¿‘è¾¹ç¼˜ */
      }
    }
    
    /* ç”µè¯å’Œå¾®ä¿¡çš„ç‚¹å‡»æç¤º */
    .info-cell-clickable {
      position: relative;
      
      &::after {
        content: '';
        position: absolute;
        right: 14px;
        top: 50%;
        width: 6px;
        height: 6px;
        border-top: 1px solid #94a3b8;
        border-right: 1px solid #94a3b8;
        transform: translateY(-50%) rotate(45deg);
      }
    }
  }
===== End of File: components\ContactInfoCard\index.scss =====


===== File: components\ContactInfoCard\index.tsx =====
// components/ContactInfoCard/index.tsx
import { useState } from 'react'
import { View, Text } from '@tarojs/components'
import Taro from '@tarojs/taro'
import { Toast } from '@nutui/nutui-react-taro'
// ç›´æ¥å¯¼å…¥ç±»å‹
import { ContactData } from 'src/services/api/contact/types'
import './index.scss'

interface ContactInfoCardProps {
  data: ContactData;
  onCopyWechat?: () => void;
  onPhoneCall?: () => void;
}

const ContactInfoCard: React.FC<ContactInfoCardProps> = ({ 
  data,
  onCopyWechat,
  onPhoneCall
}) => {
  const [showToast, setShowToast] = useState(false);
  const [toastContent, setToastContent] = useState('');
  const [toastIcon, setToastIcon] = useState<'success' | 'fail' | 'loading'>('success');
  
  // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
  const showMessage = (content: string, icon: 'success' | 'fail' | 'loading' = 'success') => {
    setToastContent(content);
    setToastIcon(icon);
    setShowToast(true);
  };
  
  // æ‹¨æ‰“ç”µè¯
  const makePhoneCall = () => {
    // æ·»åŠ éœ‡åŠ¨åé¦ˆ
    Taro.vibrateShort({ type: 'medium' });
    
    if (onPhoneCall) {
      onPhoneCall();
    } else {
      Taro.makePhoneCall({
        phoneNumber: data.phone,
        fail: () => {
          showMessage('æ‹¨æ‰“ç”µè¯å¤±è´¥ï¼Œè¯·é‡è¯•', 'fail');
        }
      });
    }
  };
  
  // å¤åˆ¶å¾®ä¿¡å·
  const copyWechat = () => {
    // æ·»åŠ éœ‡åŠ¨åé¦ˆ
    Taro.vibrateShort({ type: 'medium' });
    
    if (onCopyWechat) {
      onCopyWechat();
    } else {
      Taro.setClipboardData({
        data: data.wechat,
        success: () => {
          showMessage('å¾®ä¿¡å·å·²å¤åˆ¶ï¼Œå¿«å»æ·»åŠ å§');
        },
        fail: () => {
          showMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•', 'fail');
        }
      });
    }
  };
  
  // æ¸²æŸ“è”ç³»ä¿¡æ¯å•å…ƒæ ¼
  const renderInfoCell = (type: 'phone' | 'wechat' | 'time' | 'address', label: string, value: string, onClick?: () => void) => {
    const isAddress = type === 'address';
    const isClickable = Boolean(onClick);
    
    return (
      <View 
        className={`info-cell ${isAddress ? 'info-cell-address' : ''} ${isClickable ? 'info-cell-clickable' : ''}`} 
        onClick={onClick}
      >
        <View className="info-cell-content">
          <View className={`info-icon ${type}-icon`}></View>
          <View className="info-text">
            <Text className="info-label">{label}</Text>
            <Text className="info-value">{value}</Text>
          </View>
        </View>
      </View>
    );
  };
  
  return (
    <View className="contact-info">
      <View className="about-description">
        <Text>{data.description}</Text>
      </View>
      
      <View className="info-divider"></View>
      
      <View className="info-cells">
        {renderInfoCell('phone', 'ç”µè¯å’¨è¯¢', data.phone, makePhoneCall)}
        {renderInfoCell('wechat', 'å¾®ä¿¡å’¨è¯¢', data.wechat, copyWechat)}
        {renderInfoCell('time', 'è¥ä¸šæ—¶é—´', data.businessHours)}
        {renderInfoCell('address', 'å…¬å¸åœ°å€', data.address)}
      </View>
      
      {/* æç¤ºä¿¡æ¯ */}
      <Toast
        visible={showToast}
        content={toastContent}
        icon={toastIcon}
        onClose={() => setShowToast(false)}
        duration={2000}
      />
    </View>
  );
};

export default ContactInfoCard;
===== End of File: components\ContactInfoCard\index.tsx =====


===== File: components\QuickContact\index.scss =====
// src/components/QuickContact/index.scss

// å¿«é€Ÿè”ç³» - ä¿®æ”¹åçš„æ ·å¼ï¼ˆæ›´å¤§æ›´é†’ç›®çš„æŒ‰é’®ï¼‰
.quick-contact {
    display: flex;
    margin: 15px 15px 20px;
    background: #fff;
    border-radius: 12px;
    padding: 16px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    position: relative;
    z-index: 10;
    
    .contact-btn {
      flex: 1;
      margin: 0 8px;
      height: 54px;
      font-weight: 600;
      font-size: 16px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      
      &:active {
        transform: scale(0.98);
        opacity: 0.9;
      }
      
      .btn-icon {
        margin-right: 6px;
        font-size: 20px;
      }
    }
    
    .call-btn {
      background: #1155cc;
      color: #fff;
      box-shadow: 0 2px 6px rgba(17, 85, 204, 0.3);
    }
    
    .wechat-btn {
      background: #09BB07;
      color: #fff;
      box-shadow: 0 2px 6px rgba(9, 187, 7, 0.3);
      
      &.disabled {
        opacity: 0.7;
        background: #71c371;
        box-shadow: none;
      }
    }
  }
  
  // å“åº”å¼é€‚é…
  @media screen and (max-width: 375px) {
    .quick-contact {
      padding: 12px;
      
      .contact-btn {
        height: 48px;
        font-size: 14px;
      }
    }
  }
===== End of File: components\QuickContact\index.scss =====


===== File: components\QuickContact\index.tsx =====
// src/components/QuickContact/index.tsx
import { useState } from 'react'
import { View, Text } from '@tarojs/components'
import Taro from '@tarojs/taro'
import './index.scss'

interface ContactInfo {
  phone: string;
  wechat: string;
}

interface QuickContactProps {
  contactInfo: ContactInfo;
  onShowToast?: (message: string, type: 'success' | 'fail' | 'warn') => void;
}

const QuickContact: React.FC<QuickContactProps> = ({ 
  contactInfo,
  onShowToast
}) => {
  // å¾®ä¿¡å¤åˆ¶çŠ¶æ€
  const [isProcessingWechat, setIsProcessingWechat] = useState(false);

  // ç”µè¯å’¨è¯¢
  const handleCall = () => {
    if (!contactInfo?.phone) return;
    
    Taro.makePhoneCall({
      phoneNumber: contactInfo.phone
    }).catch(err => {
      if (err.errMsg && !err.errMsg.includes('cancel')) {
        onShowToast?.('æ‹¨å·å¤±è´¥', 'fail');
      }
    });
  };

  // å¾®ä¿¡å’¨è¯¢ - ä½¿ç”¨ç³»ç»Ÿé»˜è®¤æç¤º
  const handleWechat = () => {
    if (!contactInfo?.wechat || isProcessingWechat) return;
    
    setIsProcessingWechat(true);
    
    Taro.setClipboardData({
      data: contactInfo.wechat,
      success: function (res) {
        // ä½¿ç”¨ç³»ç»Ÿé»˜è®¤æç¤ºï¼Œä¸æ·»åŠ è‡ªå®šä¹‰Toast
      },
      fail: (err) => {
        if (!err.errMsg?.includes('cancel')) {
          onShowToast?.('å¤åˆ¶å¤±è´¥', 'fail');
        }
      },
      complete: () => {
        setTimeout(() => {
          setIsProcessingWechat(false);
        }, 1600); // ç³»ç»Ÿæç¤º1.5ç§’ï¼Œç¨å¾®å¤šç­‰ä¸€ç‚¹æ—¶é—´
      }
    });
  };

  return (
    <View className='quick-contact'>
      <View 
        className='contact-btn call-btn'
        onClick={handleCall}
      >
        <Text className='btn-icon'>ğŸ“</Text> ç”µè¯å’¨è¯¢
      </View>
      <View 
        className={`contact-btn wechat-btn ${isProcessingWechat ? 'disabled' : ''}`}
        onClick={(e) => {
          if (isProcessingWechat) return;
          e?.stopPropagation && e.stopPropagation();
          handleWechat();
        }}
      >
        <Text className='btn-icon'>ğŸ’¬</Text> å¾®ä¿¡å’¨è¯¢
      </View>
    </View>
  );
};

export default QuickContact;
===== End of File: components\QuickContact\index.tsx =====


===== File: index.html =====
<!DOCTYPE html>
<html>
<head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <meta content="width=device-width,initial-scale=1,user-scalable=no" name="viewport">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-touch-fullscreen" content="yes">
  <meta name="format-detection" content="telephone=no,address=no">
  <meta name="apple-mobile-web-app-status-bar-style" content="white">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" >
  <title>waterproof</title>
  <script><%= htmlWebpackPlugin.options.script %></script>
</head>
<body>
  <div id="app"></div>
</body>
</html>
===== End of File: index.html =====


===== File: pages\contact\index.config.ts =====
export default definePageConfig({
    navigationBarTitleText: 'è”ç³»æˆ‘ä»¬'
  })
===== End of File: pages\contact\index.config.ts =====


===== File: pages\contact\index.scss =====
// pages/contact/index.scss
// é¡µé¢æ•´ä½“æ ·å¼ä¼˜åŒ–
.contact-page {
  min-height: 100vh;
  background: linear-gradient(160deg, #f8fafc 0%, #f1f5f9 100%);
  padding: 16px 12px;
  box-sizing: border-box;
}

// åŠ è½½å®¹å™¨ä¼˜åŒ–
.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  
  .loading-text {
    margin-top: 16px;
    font-size: 14px;
    color: #64748b;
  }
}

// å†…å®¹å®¹å™¨ä¼˜åŒ–
.contact-container {
  max-width: 600px;
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

// å¡ç‰‡é€šç”¨æ ·å¼ä¼˜åŒ–
.contact-card {
  background: #ffffff;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06);
  overflow: visible; /* ç¡®ä¿å†…å®¹ä¸è¢«æˆªæ–­ */
  margin-bottom: 16px;
  
  // é¢„çº¦å¡ç‰‡ç‰¹æ®Šæ ·å¼ä¼˜åŒ–
  &.booking-card {
    background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
    border: 1px solid rgba(203, 213, 225, 0.5);
  }
  
  // å…³äºæˆ‘ä»¬å¡ç‰‡ç‰¹æ®Šæ ·å¼ä¼˜åŒ–
  &.about-card {
    background: linear-gradient(145deg, #ffffff 0%, #f0f9ff 100%);
    border: 1px solid rgba(186, 230, 253, 0.5);
  }
}

// å¡ç‰‡å¤´éƒ¨æ ·å¼ä¼˜åŒ–
.card-header {
  padding: 16px 16px 14px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.05);
}

.card-title {
  display: block;
  font-size: 18px;
  font-weight: 600;
  color: #1e293b;
  margin-bottom: 4px;
}

.card-subtitle {
  display: block;
  font-size: 13px;
  color: #64748b;
}

// å¡ç‰‡å†…å®¹åŒºåŸŸä¼˜åŒ–
.card-content {
  padding: 16px;
  overflow: visible; /* ç¡®ä¿å†…å®¹ä¸è¢«æˆªæ–­ */
}

// å“åº”å¼æ ·å¼ä¼˜åŒ–
@media screen and (min-width: 768px) {
  .contact-page {
    padding: 24px;
  }
  
  .contact-container {
    max-width: 720px;
    display: grid;
    grid-template-columns: 6fr 5fr;
    gap: 20px;
  }
  
  .contact-card {
    margin-bottom: 0;
    height: fit-content;
  }
  
  .about-card {
    position: sticky;
    top: 24px;
  }
}

@media screen and (max-width: 375px) {
  .contact-page {
    padding: 12px 10px;
  }
  
  .card-header {
    padding: 14px 12px 12px;
  }
  
  .card-content {
    padding: 14px 12px;
  }
}
===== End of File: pages\contact\index.scss =====


===== File: pages\contact\index.tsx =====
// pages/contact/index.tsx
import { useState, useEffect } from 'react'
import { View, Text } from '@tarojs/components'
import Taro from '@tarojs/taro'
import { Loading, Toast } from '@nutui/nutui-react-taro'
import BookingForm from '../../components/BookingForm'
import ContactInfoCard from '../../components/ContactInfoCard'
import './index.scss'

// ç›´æ¥å¯¼å…¥æ‰€éœ€ç±»å‹å’Œå‡½æ•°
import { 
  ServiceType, 
  ContactData, 
  BookingFormData 
} from 'src/services/api/contact/types'
import { 
  getServiceTypes, 
  getContactData, 
  submitBooking, 
  handleContactError 
} from 'src/services/api/contact/contactApi'

export default function ContactPage() {
  // é¡µé¢çŠ¶æ€
  const [loading, setLoading] = useState(true);
  const [submitting, setSubmitting] = useState(false);
  const [] = useState(false);
  const [showToast, setShowToast] = useState(false);
  const [toastInfo, setToastInfo] = useState({ content: '', icon: 'success' });
  
  // æ•°æ®çŠ¶æ€
  const [serviceTypes, setServiceTypes] = useState<ServiceType[]>([]);
  const [contactData, setContactData] = useState<ContactData | null>(null);
  
  // è¡¨å•æ•°æ®
  const [formData, setFormData] = useState<Partial<BookingFormData>>({
    name: '',
    phone: '',
    serviceType: '',
    serviceTypeName: '',
    region: [],
    address: '',
    remark: ''
  });
  
  // åŠ è½½æ•°æ®
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        
        // å¹¶è¡ŒåŠ è½½æ‰€æœ‰æ•°æ®
        const [serviceTypesRes, contactDataRes] = await Promise.all([
          getServiceTypes(),
          getContactData()
        ]);
        
        // å¤„ç†æœåŠ¡ç±»å‹æ•°æ®
        if (serviceTypesRes.success && serviceTypesRes.data) {
          setServiceTypes(serviceTypesRes.data);
        } else {
          showMessage(serviceTypesRes.error || 'è·å–æœåŠ¡ç±»å‹å¤±è´¥', 'fail');
        }
        
        // å¤„ç†è”ç³»ä¿¡æ¯æ•°æ®
        if (contactDataRes.success && contactDataRes.data) {
          setContactData(contactDataRes.data);
        } else {
          showMessage(contactDataRes.error || 'è·å–è”ç³»ä¿¡æ¯å¤±è´¥', 'fail');
        }
      } catch (error) {
        console.error('åŠ è½½æ•°æ®å¤±è´¥:', error);
        showMessage('åŠ è½½æ•°æ®å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•', 'fail');
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, []);
  
  // æ˜¾ç¤ºæç¤ºæ¶ˆæ¯
  const showMessage = (content: string, icon: 'success' | 'fail' | 'loading' = 'success') => {
    setToastInfo({ content, icon });
    setShowToast(true);
  };
  
  // å¤„ç†è¡¨å•æäº¤
  const handleFormSubmit = async (data: BookingFormData) => {
    setSubmitting(true);
    
    try {
      const res = await submitBooking(data);
      
      if (res.success) {
        Taro.vibrateShort({ type: 'medium' });
        showMessage('é¢„çº¦æˆåŠŸï¼Œæˆ‘ä»¬å°†å°½å¿«ä¸æ‚¨è”ç³»ï¼');
        
        // é‡ç½®è¡¨å•
        setFormData({
          name: '',
          phone: '',
          serviceType: '',
          serviceTypeName: '',
          region: [],
          address: '',
          remark: ''
        });
      } else {
        showMessage(res.error || 'æäº¤å¤±è´¥ï¼Œè¯·é‡è¯•', 'fail');
      }
    } catch (error) {
      showMessage(handleContactError(error), 'fail');
    } finally {
      setSubmitting(false);
    }
  };
  
  // å¤„ç†æœåŠ¡ç±»å‹é€‰æ‹©
  const handleServiceTypeSelect = (typeValue: string) => {
    const selectedType = serviceTypes.find(type => type.value === typeValue);
    setFormData(prev => ({
      ...prev,
      serviceType: typeValue,
      serviceTypeName: selectedType?.text || ''
    }));
  };
  
  // æ‹¨æ‰“ç”µè¯
  const handlePhoneCall = () => {
    if (!contactData) return;
    
    Taro.makePhoneCall({
      phoneNumber: contactData.phone,
      fail: (err) => {
        // åªæœ‰å½“ä¸æ˜¯ç”¨æˆ·å–æ¶ˆæ—¶æ‰æ˜¾ç¤ºé”™è¯¯æç¤º
        if (err.errMsg && !err.errMsg.includes('cancel')) {
          showMessage('æ‹¨æ‰“ç”µè¯å¤±è´¥ï¼Œè¯·é‡è¯•', 'fail');
        }
      }
    });
  };
  
  // å¤åˆ¶å¾®ä¿¡å·
  const handleCopyWechat = () => {
    if (!contactData) return;
    
    Taro.setClipboardData({
      data: contactData.wechat,
      success: () => {
      },
      fail: () => {
        showMessage('å¤åˆ¶å¤±è´¥ï¼Œè¯·é‡è¯•', 'fail');
      }
    });
  };
  
  // åŠ è½½çŠ¶æ€
  if (loading || !contactData) {
    return (
      <View className="loading-container">
        <Loading type="spinner" color="#2563EB" />
        <Text className="loading-text">åŠ è½½ä¸­...</Text>
      </View>
    );
  }
  
  return (
    <View className="contact-page">
      <View className="contact-container">
        {/* é¢„çº¦è¡¨å•å¡ç‰‡ */}
        <View className="contact-card booking-card">
          <View className="card-header">
            <Text className="card-title">é¢„çº¦æœåŠ¡</Text>
            <Text className="card-subtitle">å¡«å†™ä¿¡æ¯å…è´¹ä¸Šé—¨å‹˜æµ‹</Text>
          </View>
          <View className="card-content">
            <BookingForm 
              serviceTypes={serviceTypes}
              loading={submitting}
              initialValues={formData}
              onSubmit={handleFormSubmit}
              onServiceTypeSelect={handleServiceTypeSelect}
            />
          </View>
        </View>
        
        {/* å…³äºæˆ‘ä»¬å¡ç‰‡ */}
        <View className="contact-card about-card">
          <View className="card-header">
            <Text className="card-title">å…³äºæˆ‘ä»¬</Text>
            <Text className="card-subtitle">ä¸“ä¸šé˜²æ°´æœåŠ¡åå¹´</Text>
          </View>
          <View className="card-content">
            <ContactInfoCard 
              data={contactData}
              onPhoneCall={handlePhoneCall}
              onCopyWechat={handleCopyWechat}
            />
          </View>
        </View>
      </View>
      
      {/* æç¤ºä¿¡æ¯ */}
      <Toast
        visible={showToast}
        content={toastInfo.content}
        icon={toastInfo.icon as any}
        onClose={() => setShowToast(false)}
        duration={2000}
      />
    </View>
  );
}
===== End of File: pages\contact\index.tsx =====


===== File: services\api\contact\contactApi.ts =====
// services/api/contact/contactApi.ts
import http from '../../http';
import { ServiceType, ContactData, BookingFormData, ApiResponse } from './types';
import { serviceTypes, contactData } from './data';

// APIç«¯ç‚¹
const ENDPOINTS = {
  GET_SERVICE_TYPES: '/contact/service-types',
  GET_CONTACT_INFO: '/contact/info',
  SUBMIT_BOOKING: '/contact/booking'
};

/**
 * è·å–æœåŠ¡ç±»å‹åˆ—è¡¨
 */
export const getServiceTypes = async (): Promise<ApiResponse<ServiceType[]>> => {
  try {
    // æ¨¡æ‹ŸAPIè°ƒç”¨å»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 500));
    
    return {
      success: true,
      data: serviceTypes
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || 'è·å–æœåŠ¡ç±»å‹å¤±è´¥'
    };
  }
};

/**
 * è·å–è”ç³»ä¿¡æ¯
 */
export const getContactData = async (): Promise<ApiResponse<ContactData>> => {
  try {
    // æ¨¡æ‹ŸAPIè°ƒç”¨å»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 500));
    
    return {
      success: true,
      data: contactData
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || 'è·å–è”ç³»ä¿¡æ¯å¤±è´¥'
    };
  }
};

/**
 * æäº¤é¢„çº¦ä¿¡æ¯
 */
export const submitBooking = async (data: BookingFormData): Promise<ApiResponse<{ bookingId: string }>> => {
  try {
    // æ¨¡æ‹ŸAPIè°ƒç”¨å»¶è¿Ÿ
    await new Promise(resolve => setTimeout(resolve, 1200));
    
    // æ¨¡æ‹ŸæˆåŠŸå“åº”
    return {
      success: true,
      data: {
        bookingId: `BK${Date.now().toString().slice(-6)}`
      }
    };
  } catch (error: any) {
    return {
      success: false,
      error: error.message || 'æäº¤é¢„çº¦å¤±è´¥'
    };
  }
};

/**
 * é”™è¯¯å¤„ç†å·¥å…· - é‡å‘½åä¸ºhandleContactError
 */
export const handleContactError = (err: any): string => {
  console.error(err);
  return err instanceof Error ? err.message : 'å‘ç”ŸæœªçŸ¥é”™è¯¯';
};

// å¯¼å‡ºç±»å‹å’Œæ•°æ®
export * from './types';
export * from './data';
===== End of File: services\api\contact\contactApi.ts =====


===== File: services\api\contact\data.ts =====
import { ServiceType, ContactData } from './types';

// æœåŠ¡ç±»å‹æ•°æ®
export const serviceTypes: ServiceType[] = [
  { text: 'æ¼æ°´æ£€æµ‹', value: 'detection' },
  { text: 'æ¸—æ¼ç»´ä¿®', value: 'repair' },
  { text: 'é˜²æ°´æ–½å·¥', value: 'construction' }
];

// è”ç³»ä¿¡æ¯æ•°æ®
export const contactData: ContactData = {
  description: 'æˆ‘ä»¬æ˜¯ä¸€å®¶ä¸“ä¸šä»äº‹é˜²æ°´å·¥ç¨‹çš„å…¬å¸ï¼Œæ‹¥æœ‰åå¹´è¡Œä¸šç»éªŒå’Œä¸“ä¸šæŠ€æœ¯å›¢é˜Ÿã€‚æˆ‘ä»¬æœåŠ¡äºå„ç±»ä½å®…å’Œå•†ä¸šå»ºç­‘ï¼Œæä¾›é«˜è´¨é‡çš„é˜²æ°´è§£å†³æ–¹æ¡ˆã€‚æ‰€æœ‰å·¥ç¨‹å‡æä¾›è´¨ä¿ï¼Œç¡®ä¿é˜²æ°´æ•ˆæœæŒä¹…å¯é ã€‚',
  phone: '400-123-4567',
  wechat: 'waterproof123',
  businessHours: 'å‘¨ä¸€è‡³å‘¨å…­ 9:00-18:00',
  address: 'ä¸Šæµ·å¸‚æµ¦ä¸œæ–°åŒºå¼ æ±Ÿé«˜ç§‘æŠ€å›­åŒºç§‘è‹‘è·¯88å·'
};
===== End of File: services\api\contact\data.ts =====


===== File: services\api\contact\types.ts =====
// æœåŠ¡ç±»å‹æ¥å£
export interface ServiceType {
  text: string;
  value: string;
}

// è”ç³»ä¿¡æ¯æ•°æ®æ¥å£
export interface ContactData {
  description: string;
  phone: string;
  wechat: string;
  businessHours: string;
  address: string;
}

// é¢„çº¦è¡¨å•æ•°æ®æ¥å£
export interface BookingFormData {
  name: string;
  phone: string;
  area: string;
  serviceType: string;
  serviceTypeName: string;
  region: string[];
  address: string;
  remark: string;
}

// APIå“åº”åŒ…è£…å™¨
export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}
===== End of File: services\api\contact\types.ts =====


===== File: services\http\cache.ts =====
import Taro from '@tarojs/taro';
import type { CacheData } from './types';

// ç¼“å­˜é”®å‰ç¼€
const CACHE_PREFIX = 'http_cache_';

/**
 * ç”Ÿæˆç¼“å­˜é”®
 */
export function generateCacheKey(url: string, data?: any): string {
  return `${CACHE_PREFIX}${url}_${JSON.stringify(data || {})}`;
}

/**
 * è·å–ç¼“å­˜æ•°æ®
 */
export function getCacheData<T>(key: string): CacheData<T> | null {
  try {
    const cacheData = Taro.getStorageSync(key);
    return cacheData ? JSON.parse(cacheData) : null;
  } catch (error) {
    console.error('è·å–ç¼“å­˜æ•°æ®å¤±è´¥', error);
    return null;
  }
}

/**
 * è®¾ç½®ç¼“å­˜æ•°æ®
 */
export function setCacheData<T>(key: string, data: T): void {
    try {
      const cacheData: CacheData<T> = {
        data,
        timestamp: Date.now()
      };
      
      Taro.setStorageSync(key, JSON.stringify(cacheData));
    } catch (error) {
      console.error('è®¾ç½®ç¼“å­˜æ•°æ®å¤±è´¥', error);
    }
  }

/**
 * æ¸…é™¤ç¼“å­˜æ•°æ®
 */
export function clearCacheData(key: string): void {
  try {
    Taro.removeStorageSync(key);
  } catch (error) {
    console.error('æ¸…é™¤ç¼“å­˜æ•°æ®å¤±è´¥', error);
  }
}

/**
 * æ¸…é™¤æ‰€æœ‰HTTPç¼“å­˜
 */
export function clearAllCache(): void {
  try {
    const storageInfo = Taro.getStorageInfoSync();
    const keys = storageInfo.keys || [];
    
    keys.forEach(key => {
      if (key.startsWith(CACHE_PREFIX)) {
        Taro.removeStorageSync(key);
      }
    });
  } catch (error) {
    console.error('æ¸…é™¤æ‰€æœ‰ç¼“å­˜å¤±è´¥', error);
  }
}

/**
 * æ£€æŸ¥ç¼“å­˜æ˜¯å¦æœ‰æ•ˆ
 */
export function isCacheValid<T>(cache: CacheData<T>, cacheTime: number): boolean {
  if (!cache || !cache.timestamp) return false;
  
  return Date.now() - cache.timestamp < cacheTime;
}
===== End of File: services\http\cache.ts =====


===== File: services\http\config.ts =====
import type { RequestConfig } from './types';

// APIåŸºç¡€URL
export const API_BASE_URL = {
  // å¼€å‘ç¯å¢ƒ
  development: 'https://dev-api.example.com/v1',
  // ç”Ÿäº§ç¯å¢ƒ
  production: 'https://api.example.com/v1'
};

// ç¯å¢ƒåˆ¤æ–­
export const ENV = process.env.NODE_ENV || 'development';

// HTTPçŠ¶æ€ç 
export const HTTP_STATUS = {
  SUCCESS: 200,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  SERVER_ERROR: 500
};

// ä¸šåŠ¡çŠ¶æ€ç 
export const BUSINESS_CODE = {
  SUCCESS: 0,           // æˆåŠŸ
  TOKEN_EXPIRED: 10001, // tokenè¿‡æœŸ
  PARAM_ERROR: 10002,   // å‚æ•°é”™è¯¯
  SERVER_ERROR: 50000   // æœåŠ¡å™¨é”™è¯¯
};

// é»˜è®¤è¯·æ±‚é…ç½®
export const DEFAULT_CONFIG: RequestConfig = {
  baseURL: API_BASE_URL[ENV],
  showLoading: true,
  loadingText: 'åŠ è½½ä¸­',
  showErrorToast: true,
  headers: {
    'Content-Type': 'application/json'
  },
  timeout: 10000,       // 10ç§’
  useCache: false,
  cacheTime: 5 * 60 * 1000,  // 5åˆ†é’Ÿ
  retry: 0,
  retryDelay: 1000,
  withToken: true
};
===== End of File: services\http\config.ts =====


===== File: services\http\errorHandler.ts =====
import Taro from '@tarojs/taro';
import { HTTP_STATUS, BUSINESS_CODE } from './config';
import type { RequestError, RequestOptions } from './types';

/**
 * å¤„ç†HTTPçŠ¶æ€é”™è¯¯
 */
export function handleHttpError(statusCode: number): RequestError {
  let message = 'æœªçŸ¥é”™è¯¯';
  
  switch (statusCode) {
    case HTTP_STATUS.BAD_REQUEST:
      message = 'è¯·æ±‚å‚æ•°é”™è¯¯';
      break;
    case HTTP_STATUS.UNAUTHORIZED:
      message = 'æœªæˆæƒï¼Œè¯·ç™»å½•';
      break;
    case HTTP_STATUS.FORBIDDEN:
      message = 'æ²¡æœ‰æƒé™è®¿é—®';
      break;
    case HTTP_STATUS.NOT_FOUND:
      message = 'è¯·æ±‚èµ„æºä¸å­˜åœ¨';
      break;
    case HTTP_STATUS.SERVER_ERROR:
      message = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯';
      break;
    default:
      message = `HTTPé”™è¯¯ (${statusCode})`;
  }
  
  return {
    code: statusCode,
    message
  };
}

/**
 * å¤„ç†ä¸šåŠ¡çŠ¶æ€é”™è¯¯
 */
export function handleBusinessError<T>(response: { code: number; message: string; data?: T }): RequestError {
  let message = response.message || 'æœªçŸ¥é”™è¯¯';
  
  switch (response.code) {
    case BUSINESS_CODE.TOKEN_EXPIRED:
      message = 'ç™»å½•å·²è¿‡æœŸï¼Œè¯·é‡æ–°ç™»å½•';
      break;
    case BUSINESS_CODE.PARAM_ERROR:
      message = 'å‚æ•°é”™è¯¯';
      break;
    case BUSINESS_CODE.SERVER_ERROR:
      message = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯';
      break;
  }
  
  return {
    code: response.code,
    message,
    data: response.data
  };
}

/**
 * å¤„ç†ç½‘ç»œé”™è¯¯
 */
export function handleNetworkError(error: any): RequestError {
  let message = 'ç½‘ç»œå¼‚å¸¸';
  
  if (error?.errMsg) {
    if (error.errMsg.includes('timeout')) {
      message = 'è¯·æ±‚è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ';
    } else if (error.errMsg.includes('fail')) {
      message = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®';
    }
  }
  
  return {
    code: -1,
    message
  };
}

/**
 * ç»¼åˆé”™è¯¯å¤„ç†
 */
export function handleRequestError(error: any, options: RequestOptions): RequestError {
  // å·²æ ¼å¼åŒ–çš„é”™è¯¯
  if (error && typeof error === 'object' && 'code' in error && 'message' in error) {
    if (options.showErrorToast) {
      Taro.showToast({
        title: error.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return error as RequestError;
  }
  
  // HTTPé”™è¯¯
  if (error && typeof error === 'object' && 'statusCode' in error) {
    const httpError = handleHttpError(error.statusCode);
    
    if (options.showErrorToast) {
      Taro.showToast({
        title: httpError.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return httpError;
  }
  
  // ç½‘ç»œé”™è¯¯
  if (error && typeof error === 'object' && 'errMsg' in error) {
    const networkError = handleNetworkError(error);
    
    if (options.showErrorToast) {
      Taro.showToast({
        title: networkError.message,
        icon: 'none',
        duration: 2000
      });
    }
    
    return networkError;
  }
  
  // å…¶ä»–é”™è¯¯
  const unknownError: RequestError = {
    code: -1,
    message: typeof error === 'string' ? error : 'æœªçŸ¥é”™è¯¯'
  };
  
  if (options.showErrorToast) {
    Taro.showToast({
      title: unknownError.message,
      icon: 'none',
      duration: 2000
    });
  }
  
  return unknownError;
}
===== End of File: services\http\errorHandler.ts =====


===== File: services\http\index.ts =====
import { request } from './request';
import type { RequestOptions} from './types';
import { addRequestInterceptor, addResponseInterceptor, addErrorInterceptor } from './interceptor';
import { clearAllCache, clearCacheData } from './cache';

/**
 * HTTPå®¢æˆ·ç«¯
 */
const http = {
  /**
   * å‘é€GETè¯·æ±‚
   */
  get: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'GET', data, ...options }),
  
  /**
   * å‘é€POSTè¯·æ±‚
   */  
  post: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'POST', data, ...options }),
  
  /**
   * å‘é€PUTè¯·æ±‚
   */
  put: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'PUT', data, ...options }),
  
  /**
   * å‘é€DELETEè¯·æ±‚
   */
  delete: <T = any>(url: string, data?: any, options?: Partial<RequestOptions>) => 
    request<T>({ url, method: 'DELETE', data, ...options }),
  
  /**
   * åŸå§‹è¯·æ±‚æ–¹æ³•
   */
  request,
  
  /**
   * æ¸…é™¤æŒ‡å®šç¼“å­˜
   */
  clearCache: clearCacheData,
  
  /**
   * æ¸…é™¤æ‰€æœ‰ç¼“å­˜
   */
  clearAllCache,
  
  /**
   * æ·»åŠ è¯·æ±‚æ‹¦æˆªå™¨
   */
  addRequestInterceptor,
  
  /**
   * æ·»åŠ å“åº”æ‹¦æˆªå™¨
   */
  addResponseInterceptor,
  
  /**
   * æ·»åŠ é”™è¯¯æ‹¦æˆªå™¨
   */
  addErrorInterceptor
};

export default http;

// å¯¼å‡ºç±»å‹
export * from './types';
export { DEFAULT_CONFIG } from './config';
===== End of File: services\http\index.ts =====


===== File: services\http\interceptor.ts =====
import Taro from '@tarojs/taro';
import type { RequestInterceptor, ResponseInterceptor, ErrorInterceptor, RequestOptions, ResponseData } from './types';
import { BUSINESS_CODE } from './config';

// è¯·æ±‚æ‹¦æˆªå™¨æ•°ç»„
const requestInterceptors: RequestInterceptor[] = [];

// å“åº”æ‹¦æˆªå™¨æ•°ç»„
const responseInterceptors: ResponseInterceptor[] = [];

// é”™è¯¯æ‹¦æˆªå™¨æ•°ç»„
const errorInterceptors: ErrorInterceptor[] = [];

/**
 * æ·»åŠ è¯·æ±‚æ‹¦æˆªå™¨
 */
export function addRequestInterceptor(interceptor: RequestInterceptor): void {
  requestInterceptors.push(interceptor);
}

/**
 * æ·»åŠ å“åº”æ‹¦æˆªå™¨
 */
export function addResponseInterceptor(interceptor: ResponseInterceptor): void {
  responseInterceptors.push(interceptor);
}

/**
 * æ·»åŠ é”™è¯¯æ‹¦æˆªå™¨
 */
export function addErrorInterceptor(interceptor: ErrorInterceptor): void {
  errorInterceptors.push(interceptor);
}

/**
 * åº”ç”¨è¯·æ±‚æ‹¦æˆªå™¨
 */
export async function applyRequestInterceptors(options: RequestOptions): Promise<RequestOptions> {
  let config = { ...options };
  
  for (const interceptor of requestInterceptors) {
    config = await interceptor(config);
  }
  
  return config;
}

/**
 * åº”ç”¨å“åº”æ‹¦æˆªå™¨
 */
export async function applyResponseInterceptors<T>(response: ResponseData<T>, options: RequestOptions): Promise<ResponseData<T>> {
  let result = { ...response };
  
  for (const interceptor of responseInterceptors) {
    result = await interceptor(result, options);
  }
  
  return result;
}

/**
 * åº”ç”¨é”™è¯¯æ‹¦æˆªå™¨
 */
export async function applyErrorInterceptors(error: any, options: RequestOptions): Promise<any> {
  let result = error;
  
  for (const interceptor of errorInterceptors) {
    result = await interceptor(result, options);
  }
  
  return result;
}

// æ·»åŠ é»˜è®¤Tokenæ‹¦æˆªå™¨
addRequestInterceptor(async (options) => {
  if (options.withToken) {
    try {
      const token = Taro.getStorageSync('token');
      if (token) {
        options.headers = {
          ...options.headers,
          'Authorization': `Bearer ${token}`
        };
      }
    } catch (error) {
      console.error('è·å–Tokenå¤±è´¥', error);
    }
  }
  
  return options;
});

// æ·»åŠ é»˜è®¤æ—¥å¿—æ‹¦æˆªå™¨
if (process.env.NODE_ENV === 'development') {
  // è¯·æ±‚æ—¥å¿—
  addRequestInterceptor((options) => {
    console.log(`[Request] ${options.method} ${options.url}`, options.data);
    return options;
  });
  
  // å“åº”æ—¥å¿—
  addResponseInterceptor((response, options) => {
    console.log(`[Response] ${options.method} ${options.url}`, response);
    return response;
  });
  
  // é”™è¯¯æ—¥å¿—
  addErrorInterceptor((error, options) => {
    console.error(`[Error] ${options.method} ${options.url}`, error);
    return error;
  });
}

// æ·»åŠ é»˜è®¤Tokenè¿‡æœŸå¤„ç†
addErrorInterceptor((error) => {
  if (error && error.code === BUSINESS_CODE.TOKEN_EXPIRED) {
    // æ¸…é™¤æœ¬åœ°Token
    Taro.removeStorageSync('token');
    
    // è·³è½¬åˆ°ç™»å½•é¡µ
    Taro.navigateTo({
      url: '/pages/login/index'
    });
  }
  
  return error;
});
===== End of File: services\http\interceptor.ts =====


===== File: services\http\request.ts =====
import Taro from '@tarojs/taro';
import type { RequestOptions, ResponseData } from './types';
import { DEFAULT_CONFIG, BUSINESS_CODE } from './config';
import { applyRequestInterceptors, applyResponseInterceptors, applyErrorInterceptors } from './interceptor';
import { handleRequestError, handleBusinessError } from './errorHandler';
import { generateCacheKey, getCacheData, setCacheData, isCacheValid } from './cache';

// è¯·æ±‚è®¡æ•°å™¨
let loadingCount = 0;

/**
 * æ˜¾ç¤ºåŠ è½½æç¤º
 */
function showLoading(text: string): void {
  loadingCount++;
  
  if (loadingCount === 1) {
    Taro.showLoading({ title: text });
  }
}

/**
 * éšè—åŠ è½½æç¤º
 */
function hideLoading(): void {
  loadingCount--;
  
  if (loadingCount === 0) {
    Taro.hideLoading();
  }
}

/**
 * å»¶è¿Ÿå‡½æ•°
 */
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * ç»Ÿä¸€è¯·æ±‚å‡½æ•°
 */
export async function request<T = any>(options: RequestOptions): Promise<T> {
  // åˆå¹¶é…ç½®
  const config = { ...DEFAULT_CONFIG, ...options };
  const { url, method = 'GET', data, baseURL, showLoading: shouldShowLoading, loadingText, useCache, cacheTime, retry, retryDelay } = config;
  
  // å®Œæ•´URL
  const fullUrl = url.startsWith('http') ? url : `${baseURL}${url.startsWith('/') ? url : `/${url}`}`;
  
  // æ£€æŸ¥ç¼“å­˜
  if (useCache && method === 'GET') {
    const cacheKey = generateCacheKey(fullUrl, data);
    const cached = getCacheData<T>(cacheKey);
    
    if (cached && isCacheValid(cached, cacheTime || DEFAULT_CONFIG.cacheTime || 0)) {
      return cached.data;
    }
  }
  
  // è¯·æ±‚å‰å¤„ç†
  let requestConfig = await applyRequestInterceptors({ ...config, url: fullUrl });
  
  // é‡è¯•è®¡æ•°
  let retryCount = retry || 0;
  
  // æ˜¾ç¤ºåŠ è½½æç¤º
  if (shouldShowLoading) {
    showLoading(loadingText || 'åŠ è½½ä¸­');
  }
  
  try {
    // å‘é€è¯·æ±‚
    const executeRequest = async (): Promise<T> => {
      try {
        const response = await Taro.request({
          url: fullUrl,
          data: requestConfig.data,
          method: requestConfig.method as any,
          header: requestConfig.headers,
          timeout: requestConfig.timeout
        });
        
        // HTTPçŠ¶æ€æ£€æŸ¥
        if (response.statusCode !== 200) {
          throw { statusCode: response.statusCode };
        }
        
        // ä¸šåŠ¡çŠ¶æ€æ£€æŸ¥
        const responseData = response.data as ResponseData<T>;
        
        if (responseData.code !== BUSINESS_CODE.SUCCESS) {
          throw handleBusinessError(responseData);
        }
        
        // å“åº”æ‹¦æˆªå¤„ç†
        const processedResponse = await applyResponseInterceptors(responseData, requestConfig);
        
        // è®¾ç½®ç¼“å­˜
        if (useCache && method === 'GET') {
          const cacheKey = generateCacheKey(fullUrl, data);
          setCacheData(cacheKey, processedResponse.data);
        }
        
        return processedResponse.data;
      } catch (error) {
        // è¯·æ±‚å¤±è´¥ä½†è¿˜æœ‰é‡è¯•æ¬¡æ•°
        if (retryCount > 0) {
          retryCount--;
          // å»¶è¿Ÿåé‡è¯•
          await delay(retryDelay || DEFAULT_CONFIG.retryDelay || 1000);
          return executeRequest();
        }
        
        // é‡è¯•æ¬¡æ•°ç”¨å®Œï¼Œå‘ä¸ŠæŠ›å‡ºé”™è¯¯
        throw error;
      }
    };
    
    return await executeRequest();
  } catch (error) {
    // é”™è¯¯å¤„ç†
    const processedError = await applyErrorInterceptors(error, requestConfig);
    throw handleRequestError(processedError, requestConfig);
  } finally {
    // éšè—åŠ è½½æç¤º
    if (shouldShowLoading) {
      hideLoading();
    }
  }
}
===== End of File: services\http\request.ts =====


===== File: services\http\types.ts =====
// è¯·æ±‚æ–¹æ³•ç±»å‹
export type RequestMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';

// è¯·æ±‚é…ç½®
export interface RequestConfig {
  // åŸºç¡€URL
  baseURL?: string;
  // æ˜¯å¦æ˜¾ç¤ºåŠ è½½æç¤º
  showLoading?: boolean;
  // åŠ è½½æç¤ºæ–‡å­—
  loadingText?: string;
  // æ˜¯å¦æ˜¾ç¤ºé”™è¯¯æç¤º
  showErrorToast?: boolean;
  // è¯·æ±‚å¤´
  headers?: Record<string, string>;
  // è¶…æ—¶æ—¶é—´(ms)
  timeout?: number;
  // æ˜¯å¦ä½¿ç”¨ç¼“å­˜(ä»…GETè¯·æ±‚)
  useCache?: boolean;
  // ç¼“å­˜æ—¶é—´(ms)
  cacheTime?: number;
  // é‡è¯•æ¬¡æ•°
  retry?: number;
  // é‡è¯•å»¶è¿Ÿ(ms)
  retryDelay?: number;
  // æ˜¯å¦è‡ªåŠ¨æºå¸¦token
  withToken?: boolean;
}

// è¯·æ±‚å‚æ•°
export interface RequestOptions extends RequestConfig {
  // è¯·æ±‚åœ°å€
  url: string;
  // è¯·æ±‚æ–¹æ³•
  method?: RequestMethod;
  // è¯·æ±‚æ•°æ®
  data?: any;
}

// å“åº”æ•°æ®ç»“æ„
export interface ResponseData<T = any> {
  code: number;
  message: string;
  data: T;
}

// ç¼“å­˜æ•°æ®ç»“æ„
export interface CacheData<T = any> {
  data: T;
  timestamp: number;
}

// é”™è¯¯ä¿¡æ¯ç»“æ„
export interface RequestError {
  code: number;
  message: string;
  data?: any;
}

// è¯·æ±‚æ‹¦æˆªå™¨
export type RequestInterceptor = (options: RequestOptions) => RequestOptions | Promise<RequestOptions>;

// å“åº”æ‹¦æˆªå™¨
export type ResponseInterceptor = <T>(response: ResponseData<T>, options: RequestOptions) => ResponseData<T> | Promise<ResponseData<T>>;

// é”™è¯¯æ‹¦æˆªå™¨
export type ErrorInterceptor = (error: any, options: RequestOptions) => any;
===== End of File: services\http\types.ts =====


===== File: styles\theme.css =====
:root,
page{
  /* ä¸»å“ç‰Œè‰²ç³» - è“è‰²ç³»åˆ—ï¼Œä»æµ…åˆ°æ·± */
  --nutui-brand-1: #EFF6FF; /* æœ€æµ…è“è‰² - é€‚åˆèƒŒæ™¯ã€é«˜äº®åŒºåŸŸ */
  --nutui-brand-2: #DBEAFE; /* æµ…è“è‰² - ç”¨äºè½»é‡å¼ºè°ƒå’ŒèƒŒæ™¯ */
  --nutui-brand-3: #BFDBFE; /* ä¸­æµ…è“è‰² - ç¦ç”¨çŠ¶æ€ */
  --nutui-brand-4: #93C5FD; /* æ¸å˜èµ·å§‹è‰² */
  --nutui-brand-5: #60A5FA; /* ä¸­é—´è¿‡æ¸¡è‰² */
  --nutui-brand-6: #3B82F6; /* ä¸»è‰²è°ƒ - äº®è“è‰² */
  --nutui-brand-7: #2563EB; /* æŒ‰å‹çŠ¶æ€è‰² - ä¸TabBaré€‰ä¸­è‰²ç›¸åŒ */
  --nutui-brand-8: #1D4ED8; /* æ·±è“è‰² - æ¸å˜ç»“æŸè‰² */
  --nutui-brand-9: #1E40AF; /* å¾ˆæ·±è“è‰² */
  --nutui-brand-10: #1E3A8A; /* æœ€æ·±è“è‰² */
  
  /* æ¸å˜è‰²è®¾ç½® */
  --nutui-brand-stop-1: #60A5FA; /* æ¸å˜èµ·å§‹è‰² - å¯¹åº”brand-5 */
  --nutui-brand-stop-2: #2563EB; /* æ¸å˜ç»“æŸè‰² - å¯¹åº”brand-7ï¼Œä¸TabBarä¸€è‡´ */
  
  /* å¼ºè°ƒè‰² - ç”¨äºç‰¹æ®Šå…ƒç´ ï¼Œé˜²æ°´ä¸»é¢˜å¯ä»¥ç”¨è“ç»¿è‰² */
  --nutui-secondary-1: #0EA5E9; /* è“ç»¿è‰²å¼ºè°ƒè‰² - ä¸æ°´ç›¸å…³ */
  
  /* ä¸»è‰²è°ƒæ˜ å°„ */
  --nutui-color-primary: #2563EB; /* ä¸TabBaré€‰ä¸­è‰²ä¿æŒä¸€è‡´ */
  --nutui-color-primary-stop-1: var(--nutui-brand-stop-1);
  --nutui-color-primary-stop-2: var(--nutui-brand-stop-2);
  --nutui-color-primary-pressed: var(--nutui-brand-8);
  --nutui-color-primary-disabled: var(--nutui-brand-3);
  --nutui-color-primary-text: #FFFFFF;
  --nutui-color-primary-light: var(--nutui-brand-2);
  
  /* æ–‡æœ¬ç³»ç»Ÿ */
  --nutui-gray-7: #1F2937; /* ä¸»è¦æ–‡æœ¬ */
  --nutui-gray-6: #4B5563; /* é‡è¦æ¬¡è¦æ–‡æœ¬ */
  --nutui-gray-5: #6B7280; /* æ¬¡è¦æ–‡æœ¬ */
  --nutui-gray-4: #9CA3AF; /* åˆ†å‰²çº¿/ç¦ç”¨æ–‡æœ¬ */
  
  /* èƒŒæ™¯ç³»ç»Ÿ */
  --nutui-gray-1: #FFFFFF; /* ç™½è‰²èƒŒæ™¯ - ä¸navigationBarèƒŒæ™¯ä¸€è‡´ */
  --nutui-gray-2: #F9FAFB; /* æµ…ç°èƒŒæ™¯ - å¡ç‰‡å†…åµŒèƒŒæ™¯ */
  --nutui-gray-3: #F3F4F6; /* ç°è‰²èƒŒæ™¯ - é¡µé¢åŸºåº•è‰² */
  
  /* åŠŸèƒ½è‰²è®¾ç½® - ä¸é˜²æ°´æœåŠ¡ä¸»é¢˜ç›¸åè°ƒ */
  --nutui-color-success: #10B981; /* æˆåŠŸè‰² - ç»¿è‰²ï¼Œä»£è¡¨å®‰å…¨å¯é  */
  --nutui-color-success-disabled: #D1FAE5;
  --nutui-color-danger: #EF4444; /* å±é™©è‰² - çº¢è‰²ï¼Œä»£è¡¨è­¦ç¤º */
  --nutui-color-danger-disabled: #FEE2E2;
  --nutui-color-warning: #F59E0B; /* è­¦å‘Šè‰² - æ©™è‰² */
  --nutui-color-warning-disabled: #FEF3C7;
  --nutui-color-info: #3B82F6; /* ä¿¡æ¯è‰² - è“è‰²ï¼Œä¸æ°´ç›¸å…³ */
  --nutui-color-info-disabled: #BFDBFE;
  --nutui-color-info-background: linear-gradient(315deg, #60A5FA 0%, #2563EB 100%);
  
  /* TabBaré¢œè‰²è®¾ç½® - ä¿æŒä¸€è‡´æ€§ */
  --nutui-tabbar-active-color: #2563EB; /* ä¸TabBaré€‰ä¸­è‰²ä¿æŒä¸€è‡´ */
  --nutui-tabbar-inactive-color: #999999; /* ä¸TabBaræœªé€‰ä¸­è‰²ä¿æŒä¸€è‡´ */

  --nutui-picker-title-ok-font-size: 16px;/*pickeré¢æ¿ç¡®è®¤å­—å·*/
  --nutui-picker-item-height: 40px; /*pickeré¢æ¿æ¯ä¸€æ¡æ•°æ®é«˜åº¦*/
  --nutui-picker-list-height: 180px;
  --nutui-picker-title-cancel-font-size: 16px;
}
===== End of File: styles\theme.css =====

